#!/usr/local/bin/php -f
<?php

namespace RPurinton\poker;
require_once(__DIR__ . '/vendor/autoload.php');
class Card
{
    public function __construct(
        private Suit $suit,
        private Rank $rank
    ) {
    }
    public function getSuit(): Suit
    {
        return $this->suit;
    }
    public function getRank(): Rank
    {
        return $this->rank;
    }
    public function __toString(): string
    {
        return $this->rank->display() . $this->suit->display();
    }
}

class Casino
{
    public array $tables = [];
    public array $players = [];
    public Pot $vault;
    public function __construct(
        private string $name
    ) {
        $this->vault = new Pot(0);
    }
    public function __toString(): string
    {
        return $this->name;
    }
    public function get_name(): string
    {
        return $this->name;
    }
    public function set_name(string $name): void
    {
        if (strlen($name) < 3) {
            throw new \Exception('Name must be at least 3 characters.');
        }
        $this->name = $name;
    }
    public function add_table(Table $table): Table
    {
        $this->tables[] = $table;
        return $table;
    }
    public function add_player(Player $player): Player
    {
        $this->players[] = $player;
        return $player;
    }
    public function deposit(float $amount): void
    {
        $this->vault->add($amount);
    }
    public function withdraw(float $amount): void
    {
        $this->vault->remove($amount);
    }
    public function buy_chips(Player $player, float $amount): void
    {
        $this->deposit($amount);
        $player->get_bankroll()->add($amount);
    }
    public function cash_out(Player $player): void
    {
        $amount = $player->get_bankroll()->get_amount();
        $this->withdraw($player->get_bankroll()->get_amount());
        $player->get_bankroll()->setAmount(0);
        echo ($player->get_name() . " left with $" . number_format($amount, 2, '.', ',') . "\n");
    }
    public function cash_out_partial(Player $player, float $amount): void
    {
        $this->withdraw($amount);
        $player->get_bankroll()->remove($amount);
        echo ($player->get_name() . " cashed out $" . number_format($amount, 2, '.', ',') . ", still has $" . $player->get_bankroll() . "\n");
    }
}

class Deck
{
    private $cards = [];
    public function __construct()
    {
        $this->cards = $this->create_deck();
    }
    public function get_cards()
    {
        return $this->cards;
    }
    public function shuffle()
    {
        shuffle($this->cards);
    }
    public function cut()
    {
        $cut = rand(1, 51);
        $this->cards = array_merge(
            array_slice($this->cards, $cut),
            array_slice($this->cards, 0, $cut)
        );
    }
    public function deal_card(array &$destination): void
    {
        $destination[] = array_pop($this->cards);
    }
    private function create_deck()
    {
        $cards = [];
        foreach (Suit::toArray() as $suit) {
            foreach (Rank::toArray() as $rank) {
                $cards[] = new Card($suit, $rank);
            }
        }
        return $cards;
    }
    public function toString()
    {
        $deck = '';
        foreach ($this->cards as $card) {
            $deck .= $card . ' ';
        }
        return $deck;
    }
}

enum TableStatus: int
{
    case WAITING_FOR_PLAYERS = 0;
    case STARTING = 1;
    case PREFLOP = 2;
    case FLOP = 3;
    case TURN = 4;
    case RIVER = 5;
    case SHOWDOWN = 6;
    case HAND_OVER = 7;
    case ALLIN = 8;
    public function display(): string
    {
        return match ($this) {
            TableStatus::WAITING_FOR_PLAYERS => 'Waiting for players',
            TableStatus::STARTING => 'Starting',
            TableStatus::PREFLOP => 'Pre-flop',
            TableStatus::FLOP => 'Flop',
            TableStatus::TURN => 'Turn',
            TableStatus::RIVER => 'River',
            TableStatus::SHOWDOWN => 'Showdown',
            TableStatus::HAND_OVER => 'Hand over',
            TableStatus::ALLIN => "Everyone's All-in",
        };
    }
}

enum PlayerStatus
{
    case STANDING;
    case WAITING_FOR_TABLE;
    case SEAT_RESERVED;
    case SEATED;
}

enum Suit
{
    case CLUBS;
    case DIAMONDS;
    case HEARTS;
    case SPADES;
    public function display(): string
    {
        return match ($this) {
            Suit::CLUBS => "c",
            Suit::DIAMONDS => "d",
            Suit::HEARTS => "h",
            Suit::SPADES => "s"
        };
    }
    public function display_long(): string
    {
        return match ($this) {
            Suit::CLUBS => 'Club',
            Suit::DIAMONDS => 'Diamond',
            Suit::HEARTS => 'Heart',
            Suit::SPADES => 'Spade',
        };
    }
    public static function toArray(): array
    {
        return [
            Suit::CLUBS,
            Suit::DIAMONDS,
            Suit::HEARTS,
            Suit::SPADES,
        ];
    }
}

enum PlayerType: string
{
    case HUMAN = "Human";
    case AI = "AI";
    public function display(): string
    {
        return match ($this) {
            PlayerType::HUMAN => "Human",
            PlayerType::AI => "AI",
        };
    }
}

enum SeatStatus
{
    case EMPTY;
    case RESERVED;
    case WAITING;
    case POSTED;
    case PLAYING;
    case SITOUT;
    case TIMEOUT;
    case FOLDED;
    case CHECKED;
    case CALLED;
    case BET;
    case RAISED;
    case ALLIN;
    case BUSTED;
    case UPCOMING_ACTION;
    public function active(): bool
    {
        return match ($this) {
            SeatStatus::UPCOMING_ACTION,
            SeatStatus::POSTED,
            SeatStatus::PLAYING,
            SeatStatus::CHECKED,
            SeatStatus::CALLED,
            SeatStatus::BET,
            SeatStatus::RAISED => true,
            default => false,
        };
    }
    public function display(): string
    {
        return match ($this) {
            SeatStatus::EMPTY => "Empty",
            SeatStatus::RESERVED => "Reserved",
            SeatStatus::WAITING => "Waiting",
            SeatStatus::POSTED => "Posted",
            SeatStatus::PLAYING => "Playing",
            SeatStatus::SITOUT => "Sitout",
            SeatStatus::TIMEOUT => "Timeout",
            SeatStatus::FOLDED => "Folded",
            SeatStatus::CHECKED => "Checked",
            SeatStatus::CALLED => "Called",
            SeatStatus::BET => "Bet",
            SeatStatus::RAISED => "Raised",
            SeatStatus::ALLIN => "All-in",
            SeatStatus::BUSTED => "Eliminated",
            SeatStatus::UPCOMING_ACTION => "Upcoming Action",
        };
    }
}

enum Limit
{
    case NL;
    case PL;
    case FL;
    public function display(): string
    {
        return match ($this) {
            Limit::NL => 'No Limit',
            Limit::PL => 'Pot Limit',
            Limit::FL => 'Fixed Limit',
        };
    }
    public static function toArray(): array
    {
        return [
            Limit::NL,
            Limit::PL,
            Limit::FL,
        ];
    }
}

enum Rank: int
{
    case TWO = 2;
    case THREE = 3;
    case FOUR = 4;
    case FIVE = 5;
    case SIX = 6;
    case SEVEN = 7;
    case EIGHT = 8;
    case NINE = 9;
    case TEN = 10;
    case JACK = 11;
    case QUEEN = 12;
    case KING = 13;
    case ACE = 14;
    public function display(): string
    {
        return match ($this) {
            self::TWO => '2',
            self::THREE => '3',
            self::FOUR => '4',
            self::FIVE => '5',
            self::SIX => '6',
            self::SEVEN => '7',
            self::EIGHT => '8',
            self::NINE => '9',
            self::TEN => 'T',
            self::JACK => 'J',
            self::QUEEN => 'Q',
            self::KING => 'K',
            self::ACE => 'A',
        };
    }
    public function display_long(): string
    {
        return match ($this) {
            self::TWO => 'Deuce',
            self::THREE => 'Three',
            self::FOUR => 'Four',
            self::FIVE => 'Five',
            self::SIX => 'Six',
            self::SEVEN => 'Seven',
            self::EIGHT => 'Eight',
            self::NINE => 'Nine',
            self::TEN => 'Ten',
            self::JACK => 'Jack',
            self::QUEEN => 'Queen',
            self::KING => 'King',
            self::ACE => 'Ace',
        };
    }
    public function numeric(): int
    {
        return match ($this) {
            self::TWO => 2,
            self::THREE => 3,
            self::FOUR => 4,
            self::FIVE => 5,
            self::SIX => 6,
            self::SEVEN => 7,
            self::EIGHT => 8,
            self::NINE => 9,
            self::TEN => 10,
            self::JACK => 11,
            self::QUEEN => 12,
            self::KING => 13,
            self::ACE => 14,
        };
    }
    public static function toArray(): iterable
    {
        return [
            self::TWO,
            self::THREE,
            self::FOUR,
            self::FIVE,
            self::SIX,
            self::SEVEN,
            self::EIGHT,
            self::NINE,
            self::TEN,
            self::JACK,
            self::QUEEN,
            self::KING,
            self::ACE,
        ];
    }
}

enum GameType: int
{
    case TEXAS_HOLDEM = 1;
    case OMAHA = 2;
    case OMAHA_HILO = 3;
    public function display()
    {
        return match ($this) {
            GameType::TEXAS_HOLDEM => 'Texas Hold \'Em',
            GameType::OMAHA => 'Omaha',
            GameType::OMAHA_HILO => 'Omaha Hi/Lo',
        };
    }
    public function num_hole_cards()
    {
        return match ($this) {
            GameType::TEXAS_HOLDEM => 2,
            GameType::OMAHA, GameType::OMAHA_HILO => 4,
        };
    }
}

use JetBrains\PhpStorm\Internal\ReturnTypeContract;
class HandEvaluator
{
    public function __construct(private GameType $GameType)
    {
    }
    public function setGameType(GameType $GameType): void
    {
        $this->GameType = $GameType;
    }
    public function hand_toString(array $holeCards, array $communityCards): string
    {
        switch ($this->GameType) {
            case GameType::TEXAS_HOLDEM:
                return $this->hand_toString_texas($this->get_combos_texas($holeCards, $communityCards));
            default:
                return "Unknown Game Type";
        }
    }
    public function hand_toString_texas(array $combos): string
    {
        if (StraightFlush::is($combos)) return StraightFlush::toString($combos);
        if (FourofaKind::is($combos)) return FourofaKind::toString($combos);
        if (FullHouse::is($combos)) return FullHouse::toString($combos);
        if (Flush::is($combos)) return Flush::toString($combos);
        if (Straight::is($combos)) return Straight::toString($combos);
        if (ThreeofaKind::is($combos)) return ThreeofaKind::toString($combos);
        if (TwoPair::is($combos)) return TwoPair::toString($combos);
        if (Pair::is($combos)) return Pair::toString($combos);
        return HighCard::toString($combos);
    }
    public function hand_toRank(array $combos): int
    {
        if (StraightFlush::is($combos)) return 8;
        if (FourofaKind::is($combos)) return 7;
        if (FullHouse::is($combos)) return 6;
        if (Flush::is($combos)) return 5;
        if (Straight::is($combos)) return 4;
        if (ThreeofaKind::is($combos)) return 3;
        if (TwoPair::is($combos)) return 2;
        if (Pair::is($combos)) return 1;
        return 0;
    }
    public function hand_get_best_combo1(array $combos)
    {
        if (StraightFlush::is($combos)) return StraightFlush::best(StraightFlush::possibles($combos));
        if (FourofaKind::is($combos)) return FourofaKind::best(FourofaKind::possibles($combos));
        if (FullHouse::is($combos)) return FullHouse::best(FullHouse::possibles($combos));
        if (Flush::is($combos)) return Flush::best(Flush::possibles($combos));
        if (Straight::is($combos)) return Straight::best(Straight::possibles($combos));
        if (ThreeofaKind::is($combos)) return ThreeofaKind::best(ThreeofaKind::possibles($combos));
        if (TwoPair::is($combos)) return TwoPair::best(TwoPair::possibles($combos));
        if (Pair::is($combos)) return Pair::best(Pair::possibles($combos));
        return HighCard::best(HighCard::possibles($combos));
    }
    public function hand_get_best_combo2(array $best): array
    {
        foreach ($best as $hand) return $hand["hand"];
    }
    public function get_winner_indexes(array $hands, array $communityCards): array
    {
        switch ($this->GameType) {
            case GameType::TEXAS_HOLDEM:
                return $this->get_winner_indexes_texas($hands, $communityCards);
            default:
                return [];
        }
    }
    public function get_winner_indexes_texas(array $hands, array $communityCards): array
    {
        $high_rank = 0;
        foreach ($hands as $index => $hand) {
            $hands[$index]["combos"] = $this->get_combos_texas($hand, $communityCards);
            $hands[$index]["display"] = $this->hand_toString($hand, $communityCards);
            $hands[$index]["rank"] = $this->hand_toRank($hands[$index]["combos"]);
            $hands[$index]["best_combo"] = $this->hand_get_best_combo2(($this->hand_get_best_combo1($hands[$index]["combos"])));
            if ($hands[$index]["rank"] > $high_rank) $high_rank = $hands[$index]["rank"];
        }
        foreach ($hands as $index => $hand) {
            if ($hand["rank"] < $high_rank) unset($hands[$index]);
        }
        if (count($hands) < 2) foreach ($hands as $index => $hand) {
            return [$index => $hand];
        }
        $contenders = [];
        foreach ($hands as $index => $hand) $contenders[$index] = $hand["best_combo"];
        switch ($high_rank) {
            case 8:
                $best = StraightFlush::best(StraightFlush::possibles($contenders));
                break;
            case 7:
                $best = FourofaKind::best(FourofaKind::possibles($contenders));
                break;
            case 6:
                $best = FullHouse::best(FullHouse::possibles($contenders));
                break;
            case 5:
                $best = Flush::best(Flush::possibles($contenders));
                break;
            case 4:
                $best = Straight::best(Straight::possibles($contenders));
                break;
            case 3:
                $best = ThreeofaKind::best(ThreeofaKind::possibles($contenders));
                break;
            case 2:
                $best = TwoPair::best(TwoPair::possibles($contenders));
                break;
            case 1:
                $best = Pair::best(Pair::possibles($contenders));
                break;
            default:
                $best = HighCard::best(HighCard::possibles($contenders));
        }
        return $best;
    }
    private function get_combos_texas(array $holeCards, array $communityCards): array
    {
                switch (count($communityCards)) {
            case 0:
                return [$this->sort($holeCards)];
            case 3:
                return [$this->sort(array_merge($holeCards, $communityCards))];
            case 4:
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                return $combos;
            case 5:
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                return $combos;
        }
    }
    private function sort(array $combo)
    {
                usort($combo, function ($a, $b) {
            return $a->getRank()->numeric() - $b->getRank()->numeric();
        });
        return $combo;
    }
}

class Player
{
    private PlayerStatus $status = PlayerStatus::STANDING;
    private ?Pot $bankroll;
    public function __construct(
        private string $name,
        public PlayerType $type = PlayerType::HUMAN,
        public bool $auto_top_up = true
    ) {
        $this->bankroll = new Pot(0);
    }
    public function get_name(): string
    {
        return $this->name;
    }
    public function get_bankroll(): Pot
    {
        return $this->bankroll;
    }
    public function setBankroll(Pot $bankroll): void
    {
        $this->bankroll = $bankroll;
    }
    public function set_status(PlayerStatus $status): void
    {
        $this->status = $status;
    }
    public function __toString(): string
    {
        return $this->name;
    }
}

class Pair
{
    public static function is(array $combos): bool
    {
        if (count($combos) === 1) foreach ($combos as $combo) if (count($combo) === 2) {
            return $combo[0]->getRank()->numeric() === $combo[1]->getRank()->numeric();
        }
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            if (count($combo) === 2) {
                if ($combo[0]->getRank()->numeric() === $combo[1]->getRank()->numeric()) {
                    return [
                        [
                            "hand" => $combo,
                            "main" => $combo[0]->getRank()->numeric(),
                            "display" => "Pocket " . $combo[0]->getRank()->display_long() . "s"
                        ]
                    ];
                }
            }
            $pair_string = "";
            foreach ($combo as $card) {
                $pair_string .= $card->getRank()->display();
            }
            if ($pair_string[0] === $pair_string[1]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main" => $combo[0]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "kicker3" => $combo[2]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[1] === $pair_string[2]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main" => $combo[1]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[1]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[2] === $pair_string[3]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main" => $combo[2]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[1]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[2]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[3] === $pair_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main" => $combo[3]->getRank()->numeric(),
                    "kicker1" => $combo[2]->getRank()->numeric(),
                    "kicker2" => $combo[1]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[3]->getRank()->display_long() . "s (" . $combo[2]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        foreach ($possibles as $possible) {
            if ($possible["main"] > $best_main) {
                $best_main = $possible["main"];
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class ThreeofaKind
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $tok_string = "";
            foreach ($combo as $card) {
                $tok_string .= $card->getRank()->display();
            }
            if ($tok_string[0] === $tok_string[1] && $tok_string[1] === $tok_string[2]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . "/" . $combo[3]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tok_string[1] === $tok_string[2] && $tok_string[2] === $tok_string[3]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[1]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[0]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[1]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . "/" . $combo[0]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tok_string[2] === $tok_string[3] && $tok_string[3] === $tok_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[2]->getRank()->numeric(),
                    "kicker1" => $combo[1]->getRank()->numeric(),
                    "kicker2" => $combo[0]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[2]->getRank()->display_long() . "s (" . $combo[1]->getRank()->display_long() . "/" . $combo[0]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class TwoPair
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $tp_string = "";
            foreach ($combo as $card) {
                $tp_string .= $card->getRank()->display();
            }
            if ($tp_string[0] === $tp_string[1] && $tp_string[2] === $tp_string[3]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main1" => $combo[2]->getRank()->numeric(),
                    "main2" => $combo[0]->getRank()->numeric(),
                    "kicker" => $combo[4]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[2]->getRank()->display_long() . "s over " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tp_string[0] === $tp_string[1] && $tp_string[3] === $tp_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main1" => $combo[3]->getRank()->numeric(),
                    "main2" => $combo[0]->getRank()->numeric(),
                    "kicker" => $combo[2]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[3]->getRank()->display_long() . "s over " . $combo[0]->getRank()->display_long() . "s (" . $combo[2]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tp_string[1] === $tp_string[2] && $tp_string[3] === $tp_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main1" => $combo[3]->getRank()->numeric(),
                    "main2" => $combo[1]->getRank()->numeric(),
                    "kicker" => $combo[0]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[3]->getRank()->display_long() . "s over " . $combo[1]->getRank()->display_long() . "s (" . $combo[0]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main1 = 0;
        $best_main2 = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main1"] > $best_main1) {
                $best_main1 = $possible["main1"];
                $best_main2 = $possible["main2"];
                $best_kicker = $possible["kicker"];
            }
            if ($possible["main1"] === $best_main1 && $possible["main2"] > $best_main2) {
                $best_main2 = $possible["main2"];
                $best_kicker = $possible["kicker"];
            }
            if ($possible["main1"] === $best_main1 && $possible["main2"] === $best_main2 && $possible["kicker"] > $best_kicker) {
                $best_kicker = $possible["kicker"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main1"] === $best_main1 && $possible["main2"] === $best_main2 && $possible["kicker"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Flush
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $flush_string = "";
            foreach ($combo as $card) {
                $flush_string .= $card->getSuit()->display();
            }
            $flush = false;
            if ($flush_string == "ccccc") $flush = true;
            if ($flush_string == "ddddd") $flush = true;
            if ($flush_string == "hhhhh") $flush = true;
            if ($flush_string == "sssss") $flush = true;
            if ($flush) $possibles[$index] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "kicker2" => $combo[3]->getRank()->numeric(),
                "kicker3" => $combo[2]->getRank()->numeric(),
                "kicker4" => $combo[1]->getRank()->numeric(),
                "kicker5" => $combo[0]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . " High FLUSH [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        $best_kicker4 = 0;
        $best_kicker5 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] > $best_kicker4) {
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] > $best_kicker5) {
                $best_kicker5 = $possible["kicker5"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] === $best_kicker5) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Straight
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $straight_string = "";
            foreach ($combo as $card) {
                $straight_string .= $card->getRank()->display();
            }
            $flush = false;
            $straight = false;
            if ($straight_string == "2345A") $straight = true;
            if ($straight_string == "23456") $straight = true;
            if ($straight_string == "34567") $straight = true;
            if ($straight_string == "45678") $straight = true;
            if ($straight_string == "56789") $straight = true;
            if ($straight_string == "6789T") $straight = true;
            if ($straight_string == "789TJ") $straight = true;
            if ($straight_string == "89TJQ") $straight = true;
            if ($straight_string == "9TJQK") $straight = true;
            if ($straight_string == "TJQKA") $straight = true;
            if ($flush && $straight) $possibles[$index] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . " High STRAIGHT [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class FourofaKind
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $fok_string = "";
            foreach ($combo as $card) {
                $fok_string .= $card->getRank()->display();
            }
            if ($fok_string[0] === $fok_string[1] && $fok_string[1] === $fok_string[2] && $fok_string[2] === $fok_string[3]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker_rank" => $combo[4]->getRank()->numeric(),
                    "display" => "FOUR-OF-A-KIND " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($fok_string[1] === $fok_string[2] && $fok_string[2] === $fok_string[3] && $fok_string[3] === $fok_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[1]->getRank()->numeric(),
                    "kicker_rank" => $combo[0]->getRank()->numeric(),
                    "display" => "FOUR-OF-A-KIND " . $combo[1]->getRank()->display_long() . "s (" . $combo[0]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker = $possible["kicker_rank"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class StraightFlush
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            $straight_string = "";
            foreach ($combo as $card) {
                $straight_string .= $card->getRank()->display();
            }
            $flush_string = "";
            foreach ($combo as $card) {
                $flush_string .= $card->getSuit()->display();
            }
            $flush = false;
            if ($flush_string == "ccccc") $flush = true;
            if ($flush_string == "ddddd") $flush = true;
            if ($flush_string == "hhhhh") $flush = true;
            if ($flush_string == "sssss") $flush = true;
            $straight = false;
            if ($straight_string == "2345A") $straight = true;
            if ($straight_string == "23456") $straight = true;
            if ($straight_string == "34567") $straight = true;
            if ($straight_string == "45678") $straight = true;
            if ($straight_string == "56789") $straight = true;
            if ($straight_string == "6789T") $straight = true;
            if ($straight_string == "789TJ") $straight = true;
            if ($straight_string == "89TJQ") $straight = true;
            if ($straight_string == "9TJQK") $straight = true;
            if ($straight_string == "TJQKA") $straight = true;
            if ($flush && $straight) $possibles[$index] = [
                "hand" => $combo,
                "kicker_rank" => $combo[4]->getRank()->numeric()
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $hand) {
            $hand = $hand["hand"];
            $high_card = $hand[4]->getRank()->display_long();
            $suit = $hand[4]->getSuit()->display_long();
            if ($high_card === "Ace") {
                return "ROYAL FLUSH of $suit [" . implode("] [", $hand) . "]";
            }
            return "$high_card high STRAIGHT FLUSH of $suit [" . implode("] [", $hand) . "]";
        }
    }
}

class FullHouse
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $fh_string = "";
            foreach ($combo as $index => $card) {
                $fh_string .= $card->getRank()->display();
            }
            if ($fh_string[0] === $fh_string[1] && $fh_string[1] === $fh_string[2] && $fh_string[3] === $fh_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker_rank" => $combo[4]->getRank()->numeric(),
                    "display" => "FULL HOUSE " . $combo[0]->getRank()->display_long() . "s of " . $combo[4]->getRank()->display_long() . "s [" . implode("] [", $combo) . "]"
                ];
            }
            if ($fh_string[0] === $fh_string[1] && $fh_string[2] === $fh_string[3] && $fh_string[3] === $fh_string[4]) {
                $possibles[$index] = [
                    "hand" => $combo,
                    "main_rank" => $combo[4]->getRank()->numeric(),
                    "kicker_rank" => $combo[0]->getRank()->numeric(),
                    "display" => "FULL HOUSE " . $combo[4]->getRank()->display_long() . "s of " . $combo[0]->getRank()->display_long() . "s [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker = $possible["kicker_rank"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class HighCard
{
    public static function is(array $combos): bool
    {
                return true;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $index => $combo) {
            if (count($combo) === 2) {
                return [
                    [
                        "hand" => $combo,
                        "kicker1" => $combo[1]->getRank()->numeric(),
                        "kicker2" => $combo[0]->getRank()->numeric(),
                        "display" => $combo[1]->getRank()->display_long() . " " . $combo[0]->getRank()->display_long() . " " . ($combo[1]->getSuit() === $combo[0]->getSuit() ? "suited" : "off-suit")
                    ]
                ];
            }
            $possibles[$index] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "kicker2" => $combo[3]->getRank()->numeric(),
                "kicker3" => $combo[2]->getRank()->numeric(),
                "kicker4" => $combo[1]->getRank()->numeric(),
                "kicker5" => $combo[0]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . " HIGH (" . $combo[3]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        $best_kicker4 = 0;
        $best_kicker5 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] > $best_kicker4) {
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] > $best_kicker5) {
                $best_kicker5 = $possible["kicker5"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] === $best_kicker5) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Pot
{
    public array $eligible = [];
    public function __construct(private float $amount = 0, public bool $good = true)
    {
        $this->amount = round($this->amount, 2);
    }
    public function add(float $amount): void
    {
        $this->amount += round($amount, 2);
    }
    public function remove(float $amount): void
    {
        $this->amount -= round($amount, 2);
    }
    public function get_amount(): float
    {
        return round($this->amount, 2);
    }
    public function setAmount(float $amount): void
    {
        $this->amount = round($amount, 2);
    }
    public function contribute(float $amount, Seat $seat)
    {
        $this->add($amount);
        $seat->get_stack()->remove($amount);
        if (!isset($this->eligible[$seat->seat_num])) $this->eligible[$seat->seat_num] = ["seat" => $seat, "contributed" => 0];
        $this->eligible[$seat->seat_num]["contributed"] += $amount;
    }
    public function uncontribute(float $amount, Seat $seat)
    {
        $this->remove($amount);
        $seat->get_stack()->add($amount);
        $this->eligible[$seat->seat_num]["contributed"] -= $amount;
        if ($this->eligible[$seat->seat_num]["contributed"] == 0) unset($this->eligible[$seat->seat_num]);
    }
    public function payout(array $winner_indexes, string $display_name): array
    {
        if ($this->amount == 0) return [];
        $results = [];
        $amount = round($this->amount / count($winner_indexes), 2);
        foreach ($winner_indexes as $index => $hand_toString) {
            $profit = $amount - $this->eligible[$index]["contributed"];
            if ($profit > 0) $plus = "+";
            if ($profit == 0) $plus = " ";
            if ($profit < 0) $plus = "-";
            $results[] = $this->eligible[$index]["seat"]->get_player()->get_name() . " wins $" . number_format($amount, 2, '.', ',') . " from " . $display_name . " with " . $hand_toString . " [$plus$" . number_format($profit, 2, '.', ',') . "]";
            $this->eligible[$index]["seat"]->get_stack()->add($amount);
            $this->remove($amount);
        }
        if ($this->amount) {
            $results[] = "The extra $" . number_format($this->amount, 2, '.', ',') . " goes to " . $this->eligible[$index]["seat"]->get_player()->get_name();
            $this->eligible[$index]["seat"]->get_stack()->add($this->amount);
            $this->remove($this->amount);
        }
        return $results;
    }
    public function payout_last_player(string $display_name): array
    {
        if ($this->amount == 0) return [];
        if (count($this->eligible) == 0) return [];
        $seat = array_pop($this->eligible);
        $profit = $this->amount - $seat["contributed"];
        if ($profit > 0) $plus = "+";
        if ($profit == 0) $plus = " ";
        if ($profit < 0) $plus = "-";
        $seat = $seat["seat"];
        $results = [];
        $results[] = $seat->get_player()->get_name() . " wins $" . number_format($this->amount, 2, '.', ',') . " from " . $display_name . " [$plus$" . number_format($profit, 2, '.', ',') . "]";
        $seat->get_stack()->add($this->amount);
        $this->remove($this->amount);
        return $results;
    }
    public function __toString(): string
    {
        return '$' . number_format($this->amount, 2, '.', ',');
    }
}

use OpenAI;
class Seat
{
    public SeatStatus $status = SeatStatus::EMPTY;
    private ?Player $player = null;
    public array $cards = [];
    private Pot $stack;
    public float $bet = 0;
    public float $total_bet = 0;
    public $openai = null;
    public function __construct(public int $seat_num, public Table $table)
    {
        $this->stack = new Pot(0);
    }
    public function get_status(): SeatStatus
    {
        return $this->status;
    }
    public function set_status(SeatStatus $status): void
    {
        $this->status = $status;
    }
    public function get_player(): ?Player
    {
        return $this->player;
    }
    public function set_player(Player $player): void
    {
        $this->player = $player;
        if ($player->type == PlayerType::AI) $this->openai = OpenAI::client(file_get_contents(__DIR__ . "/openai_token.txt"));
    }
    public function get_stack(): Pot
    {
        return $this->stack;
    }
    public function __toString(): string
    {
        return $this->player->get_name();
    }
    public function clear_cards(): void
    {
        $this->cards = [];
    }
    public function buy_chips(float $amount, bool $rebuy = false): void
    {
        $amount = min($amount, $this->player->get_bankroll()->get_amount());
        $this->player->get_bankroll()->remove($amount);
        $this->stack->add($amount);
        if ($rebuy) $this->table->chat($this->player->get_name() . " rebuys $" . number_format($amount, 2, ".", ","));
        else $this->table->chat($this->player->get_name() . " buys in for $" . number_format($amount, 2, ".", ","));
    }
    public function cash_out(): void
    {
        if (!isset($this->player)) return;
        $stack_amount = $this->stack->get_amount();
        $this->player->get_bankroll()->add($this->stack->get_amount());
        $this->stack->setAmount(0);
        $this->table->chat($this->player->get_name() . " cashes out $" . number_format($stack_amount, 2, ".", ","));
        $this->status = SeatStatus::EMPTY;
        $this->player = null;
    }
    public function top_up(float $amount): void
    {
        if (!isset($this->player)) return;
        if (!$this->player->auto_top_up) return;
        if ($this->player->get_bankroll()->get_amount() == 0 && $this->stack->get_amount() == 0) {
            $this->status = SeatStatus::SITOUT;
            return;
        }
        if ($this->player->get_bankroll()->get_amount() == 0) return;
        $current_stack = $this->stack->get_amount();
        if ($current_stack < $amount) {
            $diff_amount = $amount - $current_stack;
            $amount = min($diff_amount, $this->player->get_bankroll()->get_amount());
            $this->buy_chips($amount, true);
        }
    }
    public function prompt(array $options): void
    {
        switch ($this->player->type) {
            case PlayerType::HUMAN:
                $this->prompt_human($options);
                return;
            case PlayerType::AI:
                $this->prompt_ai($options);
                return;
        }
    }
    public function prompt_ai($options): void
    {
                                echo ($this->player->get_name() . " [" . implode("] [", $this->cards) . "] " . $this->table->HandEvaluator->hand_toString($this->cards, $this->table->communityCards) . "...\n");
        $answered = false;
        while (!$answered) {
            $messages = [];
            $model = "gpt-3.5-turbo-0613";
            $system_message2 = "Welcome to the poker game! Get ready for an exciting round of Texas Hold'em. As you navigate through each hand, remember to consider the following factors that can influence your decision-making:
                Hand Strength: Evaluate the ranking and potential of your starting hand.
                Chip Stack Size: Assess your chip stack compared to blinds and antes.
                Position at the Table: Utilize your position to make informed decisions.
                Betting History: Analyze the betting patterns and tendencies of your opponents.
                Table Dynamics: Observe player interactions, chat messages, and betting behavior.
                Blind Levels and Tournament Stage: Adapt your strategy based on the stage of the tournament and number of players at the table.
                Stack-to-Pot Ratio (SPR): Consider the relationship between your chip stack and the pot.
                Player Image: Be aware of your own table image and use it strategically.
                
                Incorporating these factors into your decision-making will lead to a more strategic and profitable gameplay experience. Good luck, and may the best hand win!";
            $messages[] = ["role" => "system", "content" => $this->minify_prompt($system_message2)];
            $system_message1 = "Your name is " . $this->player->get_name() . " and you are in seat " . $this->seat_num . " in a friendly winner-takes-all home sit-and-go tournament with your co-workers from Discommand.com\n";
            $system_message1 .= "Lily is the CEO, Adam is the Architect/CTO, Bella is the COO, Ursula is the CLO/GC, Finley is the CFO, Stella is Chief Security Officer, Derek is the MySQL DBA, Max is a Graphics Designer, and Frank is the Project Manager.\n";
            $system_message1 .= "Everyone starts with 1500 chips and the blinds start at $10/$20 and go up every 9 hands.\n";
            $system_message1 .= "You are currently in hand #" . $this->table->hand_count . " of the tournament.\n";
            $system_message1 .= "We have included the history of the table chat and the current state of the table below.\n";
            $messages[] = ["role" => "system", "content" => $this->minify_prompt($system_message1)];
            $user_message1 = implode("\n", $this->table->get_chat_history(3072));
            $messages[] = ["role" => "user", "content" => $this->minify_prompt($user_message1)];
            $user_message1 = "Current Action is on:\n";
            $user_message1 .= "Seat\tStack\tIn For\tName\tPocket\tHand\n";
            $user_message1 .= $this->seat_num . "\t" . $this->get_stack() . "\t$" . number_format($this->total_bet, 2, ".", ",") . "\t" . $this->player->get_name() . "\t [" . implode("] [", $this->cards) . "]\t" . $this->table->HandEvaluator->hand_toString($this->cards, $this->table->communityCards) . "\n";
            $user_message1 .= "Community Cards: [" . implode("] [", $this->table->communityCards) . "]\n";
            $messages[] = ["role" => "user", "content" => $this->minify_prompt($user_message1)];
            $user_message2 = "Hey " . $this->player->get_name() . " its your move... play smart!  if you have the nuts you must raise on the river! use GTO strategy to determine the best move in this specific scenario and then take_action!\n";
            $messages[] = ["role" => "user", "content" => $this->minify_prompt($user_message2)];
            $options_json = json_encode($options);
            print_r($options);
            $prompt = [
                "model" => $model,
                "messages" => $messages,
                "temperature" => 0.986,
                "top_p" => 0.986,
                "frequency_penalty" => 1,
                "presence_penalty" => 1,
                'functions' => [
                    [
                        'name' => 'take_action',
                        'description' => 'Make your move!',
                        'parameters' => [
                            'type' => 'object',
                            'properties' => [
                                'action' => [
                                    'type' => 'string',
                                    'description' => "a single lower letter representing the action you want to take of the following available options only:\n$options_json",
                                ],
                                'amount' => [
                                    'type' => 'string',
                                    'description' => 'If betting or raising, the amount you want to raise increase the total bet by or to. Numerical formatted (float value)',
                                ],
                                'chat_message' => [
                                    'type' => 'string',
                                    'description' => 'continue the chat conversation... the chat message to send to the table (playful fun good natured table banter) (fun part of the game!) (dont reapeat the same message over and over, be creative!)',
                                ],
                            ],
                            'required' => ['action', 'amount', 'chat_message']
                        ],
                    ],
                ],
            ];
            try {
                $response = $this->openai->chat()->create($prompt);
            } catch (\Exception $e) {
                echo ("Error: " . $e->getMessage() . "\n");
                continue;
            } catch (\Throwable $e) {
                echo ("Error: " . $e->getMessage() . "\n");
                continue;
            } catch (\Error $e) {
                echo ("Error: " . $e->getMessage() . "\n");
                continue;
            }
            foreach ($response->choices as $result) {
                if ($result->finishReason == "function_call") {
                    if ($result->message->functionCall->name == "take_action") {
                        $json_string = $result->message->functionCall->arguments;
                        $data = json_decode($json_string, true);
                        print_r($data);
                        if (isset($data["chat_message"]) && $data["chat_message"] != "") $this->table->chat($this->player->get_name() . " said: " . $data["chat_message"]);
                        $char = strtolower(substr($data["action"], 0, 1));
                        if ($char == "r") $char = "b";
                        if (array_key_exists($char, $options)) {
                            $answered = true;
                            switch ($char) {
                                case "c":
                                    if (substr($options["c"], 0, 4) == "Call") $this->table->call($this);
                                    else $this->table->check($this);
                                    break;
                                case "f":
                                    $this->table->fold($this);
                                    break;
                                case "b":
                                    $amount = str_replace(",", "", $data["amount"]);
                                    $amount = str_replace("$", "", $amount);
                                    $amount = str_replace("<", "", $amount);
                                    $amount = str_replace(">", "", $amount);
                                    $amount = str_replace(" ", "", $amount);
                                    $amount = str_replace("[", "", $amount);
                                    $amount = str_replace("]", "", $amount);
                                    $amount = (float)$amount;
                                    if (!is_numeric($amount) || $amount <= 0) {
                                        echo ("AI returned invalid amount (" . $data["amount"] . "), Retrying...\n");
                                        $answered = false;
                                    } else $this->table->raise_by($this, $amount);
                                    break;
                                case "a":
                                    $this->table->all_in($this);
                                    break;
                                default:
                                    echo ("AI returned invalid action (" . $data["action"] . "), Retrying...\n");
                                    $answered = false;
                                    break;
                            }
                        }
                    }
                }
            }
            if (!$answered) echo ($this->player->get_name() . " is thinking...\n");
            else echo ("\n");
        }
    }
    public function prompt_human($options): void
    {
                                echo ("=============================================================\n");
        foreach ($this->table->pots as $key => $pot) {
            if ($key == 0) $pot_display_name = "Main Pot";
            else $pot_display_name = "Side Pot " . $key;
            echo ($pot_display_name . ": $pot\n");
        }
        echo ("Seat\tStack\tIn For\tName\tPocket\tHand\n");
        echo ($this->seat_num . "\t" . $this->get_stack() . "\t$" . number_format($this->total_bet, 2, ".", ",") . "\t" . $this->player->get_name() . "\t" . $this->table->HandEvaluator->hand_toString($this->cards, $this->table->communityCards) . "\n");
        foreach ($options as $key => $option) {
            echo (" [" . strtoupper($key) . "] " . $option . "\t");
        }
        echo (" [T] Chat\n");
        echo ($this->player->get_name() . ": ");
        $valid = false;
        readline_callback_handler_install('', function () {
        });
        while (!$valid) {
            $r = [STDIN];
            $w = NULL;
            $e = NULL;
            if (stream_select($r, $w, $e, 0)) {
                $input = stream_get_contents(STDIN, 1);
                if ($input == "t") {
                    readline_callback_handler_remove();
                    echo ("\rType a message: ");
                    $handle = fopen("php://stdin", "r");
                    $message = trim(fgets($handle));
                    fclose($handle);
                    if ($message != "") $this->table->chat($this->player->get_name() . " said: " . $message);
                    readline_callback_handler_install('', function () {
                    });
                    echo ($this->player->get_name() . ": ");
                }
                if (array_key_exists($input, $options)) {
                    $valid = true;
                    $char = $input;
                }
            }
        }
        echo ("\r");
        readline_callback_handler_remove();
        switch ($char) {
            case "c":
                if (substr($options["c"], 0, 4) == "Call") $this->table->call($this);
                else $this->table->check($this);
                break;
            case "f":
                $this->table->fold($this);
                break;
            case "b":
                $amount = 0;
                while ($amount <= 0) {
                    echo ($options["b"] . ": ");
                    $handle = fopen("php://stdin", "r");
                    $amount = (float)fgets($handle);
                    fclose($handle);
                    if (!is_numeric($amount) || $amount <= 0) echo ("Invalid amount, Please try again...\n");
                }
                $this->table->raise_by($this, $amount);
                break;
            case "a":
                $this->table->all_in($this);
                break;
            case "q":
                echo ("Thanks for Playing!\n");
                exit();
                break;
        }
    }
    private function minify_prompt(string $text): string
    {
                $text = str_replace("\0", "", $text);
                $text = str_replace("\t", " ", $text);
                while (strpos($text, "  ") !== false) $text = str_replace("  ", " ", $text);
                while (strpos($text, "\n\n") !== false) $text = str_replace("\n\n", "\n", $text);
        return $text;
    }
}

class Table
{
    public array $seats = [];
    public array $config = [
        "id" => null,
        "status" => TableStatus::WAITING_FOR_PLAYERS,
        "GameType" => GameType::TEXAS_HOLDEM,
        "seats" => 9,
        "smallBlind" => 1,
        "bigBlind" => 2,
        "limit" => Limit::NL,
        "minBuyIn" => 100,
        "maxBuyIn" => 1000,
        "straddles" => 0,
        "buttonstraddle" => false,
        "straddleAmount" => 4,
    ];
    public ?Deck $deck = null;
    public array $pots = [];
    public array $communityCards = [];
    public array $muck = [];
    public HandEvaluator $HandEvaluator;
    private int $button_position = 0;
    private int $action_position = 0;
    public array $chat_history = [];
    public $hand_count = 0;
    private float $bet = 0;
    private float $last_raise_amount = 0;
    public $encoder = null;
    public function __construct(array $config = [])
    {
        $this->config = array_merge($this->config, $config);
        $this->create_seats();
        $this->deck = new Deck();
        $this->HandEvaluator = new HandEvaluator($this->config["GameType"]);
        $this->encoder = new \TikToken\Encoder;
    }
    public function get_seats(): array
    {
        return $this->seats;
    }
    public function get_GameType(): ?GameType
    {
        return $this->config['GameType'];
    }
    public function set_GameType(GameType $GameType): void
    {
        $this->config['GameType'] = $GameType;
    }
    public function get_config(): array
    {
        return $this->config;
    }
    public function set_config(array $config): void
    {
        $this->config = array_merge($this->config, $config);
    }
    private function create_seats(): void
    {
        for ($i = 1; $i <= $this->config['seats']; $i++) {
            $this->seats[$i] = new Seat($i, $this);
        }
    }
    public function set_stakes($minBuyIn, $maxBuyIn, $smallBlind, $bigBlind): void
    {
        $this->config['minBuyIn'] = $minBuyIn;
        $this->config['maxBuyIn'] = $maxBuyIn;
        $this->config['smallBlind'] = $smallBlind;
        $this->config['bigBlind'] = $bigBlind;
    }
    public function seat_player(Player $player, Seat $seat): Seat
    {
        $seat->set_player($player);
        $seat->set_status(SeatStatus::WAITING);
        $player->set_status(PlayerStatus::SEATED);
        return $seat;
    }
    public function reserve_seat(Player $player, Seat $seat): Seat
    {
        $seat->set_player($player);
        $seat->set_status(SeatStatus::RESERVED);
        $player->set_status(PlayerStatus::SEAT_RESERVED);
        return $seat;
    }
    public function new_hand(): bool
    {
        $this->hand_count++;
        $hand_count_display = number_format($this->hand_count, 0, '.', ',');
        echo ("\n\n\n===============STARTING HAND #$hand_count_display====================\n");
        $this->chat($this->config["limit"]->display() . " " . $this->config['GameType']->display() . " [$" . $this->config['smallBlind'] . "/$" . $this->config['bigBlind'] . "]");
        $this->config['status'] = TableStatus::STARTING;
        $this->muck = [];
        $this->communityCards = [];
        $this->pots = [];
        $this->pots[0] = new Pot(0, false);
        $players_ready = $this->reset_seats();
        if ($players_ready < 2) {
            $this->chat("Not enough players to start a new hand.");
            return false;
        }
        $this->advance_button();
        $this->deck = new Deck();
        $this->action_position = $this->post_blinds();
        $this->deck->shuffle();
        $this->deck->cut();
        $this->deal_cards();
        $this->config['status'] = TableStatus::PREFLOP;
        $this->betting_round();
        if ($this->config['status'] == TableStatus::HAND_OVER) return true;
        if ($this->config['status'] == TableStatus::ALLIN) {
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            $this->deck->deal_card($this->communityCards);
            $this->deck->deal_card($this->communityCards);
            echo ("================FLOP===================\n");
            $this->chat("Flop:\t[" . implode("] [", $this->communityCards) . "]");
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            echo ("================TURN===================\n");
            $this->chat("Turn:\t[" . implode("] [", $this->communityCards) . "]");
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            echo ("================RIVER==================\n");
            $this->chat("River:\t[" . implode("] [", $this->communityCards) . "]");
            $this->showdown();
            return true;
        }
        $this->config['status'] = TableStatus::FLOP;
        $this->deck->deal_card($this->muck);
        $this->deck->deal_card($this->communityCards);
        $this->deck->deal_card($this->communityCards);
        $this->deck->deal_card($this->communityCards);
        echo ("================FLOP===================\n");
        $this->chat("Flop:\t[" . implode("] [", $this->communityCards) . "]");
        $this->betting_round();
        if ($this->config['status'] == TableStatus::HAND_OVER) return true;
        if ($this->config['status'] == TableStatus::ALLIN) {
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            echo ("================TURN===================\n");
            $this->chat("Turn:\t[" . implode("] [", $this->communityCards) . "]");
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            echo ("================RIVER==================\n");
            $this->chat("River:\t[" . implode("] [", $this->communityCards) . "]");
            $this->showdown();
            return true;
        }
        $this->config['status'] = TableStatus::TURN;
        $this->deck->deal_card($this->muck);
        $this->deck->deal_card($this->communityCards);
        echo ("================TURN===================\n");
        $this->chat("Turn:\t[" . implode("] [", $this->communityCards) . "]");
        $this->betting_round();
        if ($this->config['status'] == TableStatus::HAND_OVER) return true;
        if ($this->config['status'] == TableStatus::ALLIN) {
            $this->deck->deal_card($this->muck);
            $this->deck->deal_card($this->communityCards);
            echo ("================RIVER==================\n");
            $this->chat("River:\t[" . implode("] [", $this->communityCards) . "]");
            $this->showdown();
            return true;
        }
        $this->config['status'] = TableStatus::RIVER;
        $this->deck->deal_card($this->muck);
        $this->deck->deal_card($this->communityCards);
        echo ("================RIVER==================\n");
        $this->chat("River:\t[" . implode("] [", $this->communityCards) . "]");
        $this->action_position = $this->button_position;
        $this->betting_round();
        if ($this->config['status'] == TableStatus::HAND_OVER) return true;
        $this->config['status'] = TableStatus::SHOWDOWN;
        $this->showdown();
        return true;
    }
    private function showdown(): void
    {
        $status_message =  ("\n=============SHOWDOWN!=============\n");
        foreach ($this->pots as $key => $pot) {
            if ($key == 0) $pot_display_name = "Main Pot";
            else $pot_display_name = "Side Pot " . $key;
            $eligible_seats = array_keys($pot->eligible);
            $eliglbe_player_names = [];
            foreach ($eligible_seats as $seat_num) $eliglbe_player_names[] = $this->seats[$seat_num]->get_player()->get_name() . " ($" . number_format($pot->eligible[$seat_num]["contributed"], 2, '.', ',') . ")";
            $eliglbe_player_names_string = implode(", ", $eliglbe_player_names);
            $status_message .= $pot_display_name . ": $pot [$eliglbe_player_names_string]\n";
        }
        $this->chat($status_message);
        foreach ($this->pots as $key => $pot) {
            if ($key == 0) $pot_display = "the Main Pot";
            else $pot_display = "Side Pot $key";
            $hands = [];
            foreach ($pot->eligible as $seat_num => $seat) {
                $hands[$seat_num] = $seat["seat"]->cards;
            }
            $winning_seats = $this->HandEvaluator->get_winner_indexes($hands, $this->communityCards);
            $winners = [];
            foreach ($winning_seats as $index => $best_hand) $winners[$index] = $best_hand["display"];
            $results = $pot->payout($winners, $pot_display);
            foreach ($results as $result) $this->chat($result);
        }
    }
    private function betting_round(): void
    {
        $status_message = "\n=================CURRENT POTS=================\n";
        foreach ($this->pots as $key => $pot) {
            if ($key == 0) $pot_display_name = "Main Pot";
            else $pot_display_name = "Side Pot " . $key;
            $eligible_seats = array_keys($pot->eligible);
            $eliglbe_player_names = [];
            foreach ($eligible_seats as $seat_num) $eliglbe_player_names[] = $this->seats[$seat_num]->get_player()->get_name() . " ($" . number_format($pot->eligible[$seat_num]["contributed"], 2, '.', ',') . ")";
            $eliglbe_player_names_string = implode(", ", $eliglbe_player_names);
            $status_message .= $pot_display_name . ": $pot [$eliglbe_player_names_string]\n";
        }
        $this->chat($status_message);
        $action_order = $this->get_action_order();
        if (count($action_order) < 2) {
            return;
        }
        foreach ($action_order as $seat_number) {
            $this->seats[$seat_number]->status = SeatStatus::UPCOMING_ACTION;
        }
        if ($this->config["status"] != TableStatus::PREFLOP) $this->action_position = $this->button_position;
        $this->pots[count($this->pots) - 1]->good = false;
        while (!$this->all_pots_are_good()) {
            if ($this->config["status"] == TableStatus::HAND_OVER) break;
            if ($this->config["status"] == TableStatus::ALLIN) break;
            $action_order = $this->get_action_order();
            if (count($action_order) < 1) {
                $this->config['status'] = TableStatus::ALLIN;
                break;
            }
            $seat_number = $action_order[0];
            $this->action_position = $seat_number;
            $seat = $this->seats[$seat_number];
            $available_actions = $this->get_available_actions($seat);
            if (count($available_actions)) $seat->prompt($available_actions);
            else $seat->set_status(SeatStatus::ALLIN);
            $this->check_table_all_in();
            if ($this->config['status'] == TableStatus::HAND_OVER) return;
        }
        $this->action_position = $this->button_position;
                $current_pot = count($this->pots) - 1;
        $eligible = $this->pots[$current_pot]->eligible;
        if (count($eligible) > 1) {
            $contributions = [];
            foreach ($eligible as $seat) {
                $contributions[] = $seat["contributed"];
            }
            $max_contribution = max($contributions);
            $min_contribution = min($contributions);
            while ($max_contribution > $min_contribution) {
                $this->pots[$current_pot + 1] = new Pot(0);
                $eligible = $this->pots[$current_pot]->eligible;
                $contributions = [];
                foreach ($eligible as $seat) {
                    $contributions[] = $seat["contributed"];
                }
                $max_contribution = max($contributions);
                $min_contribution = min($contributions);
                foreach ($eligible as $seat_num => $seat) {
                    if ($seat["contributed"] > $min_contribution) {
                        $diff_amount = $seat["contributed"] - $min_contribution;
                        $this->pots[$current_pot]->uncontribute($diff_amount, $seat["seat"]);
                        $this->pots[$current_pot + 1]->contribute($diff_amount, $seat["seat"]);
                    }
                }
                $current_pot++;
            }
        }
                $active_players = 0;
        foreach ($this->seats as $seat) {
            if ($seat->get_status()->active() || $seat->get_status() == SeatStatus::ALLIN) $active_players++;
        }
        if ($active_players == 1) {
            $this->config['status'] = TableStatus::HAND_OVER;
                        foreach ($this->pots as $key => $pot) {
                if ($key == 0) $pot_display = "the Main Pot";
                else $pot_display = "Side Pot $key";
                $results = $pot->payout_last_player($pot_display);
                foreach ($results as $result) $this->chat($result);
            }
        }
        $this->bet = 0;
        $this->last_raise_amount = 0;
        foreach ($this->seats as $seat) $seat->bet = 0;
    }
    private function get_available_actions(Seat $seat): array
    {
        $available_actions = [];
        if ($seat->bet < $this->bet) {
            $available_actions["f"] = "Fold";
            $bet_diff = $this->bet - $seat->bet;
            if ($seat->get_stack()->get_amount() > $bet_diff) {
                extract($this->get_min_max($seat));
                $available_actions["c"] = "Call $" . number_format($bet_diff, 2, '.', ',');
                if ($min_raise_amount_by < $max_opponent_stack) {
                    $available_actions["b"] = "Bet/Raise BY [$" . number_format($min_raise_amount_by, 2, '.', ',') . " <=> $" . number_format($max_raise_amount_by, 2, '.', ',') . "]";
                    $available_actions["a"] = "All-In for $" . number_format(min($seat->get_stack()->get_amount(), $max_opponent_stack), 2, '.', ',') . ' more';
                }
            } else if ($seat->get_stack()->get_amount() < $bet_diff) {
                $available_actions["c"] = "Call All In for Less (" . $seat->get_stack() . ")";
            } else if ($seat->get_stack()->get_amount() == $bet_diff) {
                unset($available_actions["c"]);
                $available_actions["c"] = "Call All In for " . $seat->get_stack();
            }
        } else if ($seat->bet == $this->bet) {
            extract($this->get_min_max($seat));
            $available_actions["c"] = "Check";
            if ($min_raise_amount_by < $max_opponent_stack) {
                $available_actions["b"] = "Bet/Raise BY [$" . number_format($min_raise_amount_by, 2, '.', ',') . " <=> $" . number_format($max_raise_amount_by, 2, '.', ',') . "]";
                $available_actions["a"] = "All-In for " . number_format(min($seat->get_stack()->get_amount(), $max_opponent_stack), 2, '.', ',');
            }
        }
        return $available_actions;
    }
    private function get_min_max(Seat $seat): array
    {
        $max_opponent_stack = 0;
        $max_opponent_bet = 0;
        foreach ($this->seats as $other_seat) {
            if ($other_seat->seat_num == $seat->seat_num) continue;
            if ($other_seat->get_stack()->get_amount() > $max_opponent_stack) {
                $max_opponent_stack = $other_seat->get_stack()->get_amount();
                $max_opponent_bet = $other_seat->bet;
            }
        }
        $bet_diff = $this->bet - $seat->bet;
        $min_raise_amount_by = max($this->last_raise_amount, $this->config["bigBlind"]);
        $min_raise_amount_to = $this->bet + $min_raise_amount_by;
        $max_raise_amount_by = $seat->get_stack()->get_amount() - $bet_diff;
        $max_raise_amount_to = $seat->get_stack()->get_amount() + $seat->bet;
        $min_raise_amount_by = min($min_raise_amount_by, $max_opponent_stack + $max_opponent_bet);
        $min_raise_amount_to = min($min_raise_amount_to, $max_opponent_stack);
        $max_raise_amount_by = min($max_raise_amount_by, $max_opponent_stack + $max_opponent_bet);
        $max_raise_amount_to = min($max_raise_amount_to, $max_opponent_stack);
        return [
            "min_raise_amount_by" => $min_raise_amount_by,
            "min_raise_amount_to" => $min_raise_amount_to,
            "max_raise_amount_by" => $max_raise_amount_by,
            "max_raise_amount_to" => $max_raise_amount_to,
            "bet_diff" => $bet_diff,
            "max_opponent_stack" => $max_opponent_stack,
            "max_opponent_bet" => $max_opponent_bet,
        ];
    }
    public function fold(Seat $seat): void
    {
        echo ("\r                                                                                          \r");
        $seat->set_status(SeatStatus::FOLDED);
        $this->chat($seat->get_player()->get_name() . " folds.");
        foreach ($this->pots as $pot) unset($pot->eligible[$seat->seat_num]);
                $active_players = 0;
        foreach ($this->seats as $seat) {
            if ($seat->get_status()->active() || $seat->get_status() == SeatStatus::ALLIN) $active_players++;
        }
        if ($active_players == 1) {
            $this->config['status'] = TableStatus::HAND_OVER;
                        foreach ($this->pots as $key => $pot) {
                if ($key == 0) $pot_display = "the Main Pot";
                else $pot_display = "Side Pot $key";
                $results = $pot->payout_last_player($pot_display);
                foreach ($results as $result) $this->chat($result);
            }
        }
    }
    public function pass(Seat $seat): void
    {
        $seat->set_status(SeatStatus::CHECKED);
    }
    public function check(Seat $seat): void
    {
        echo ("\r                                                                                          \r");
        $seat->set_status(SeatStatus::CHECKED);
        $this->chat($seat->get_player()->get_name() . " checks.");
    }
    public function call(Seat $seat): void
    {
        echo ("\r                                                                                          \r");
        extract($this->get_min_max($seat));
        $amount = $bet_diff;
        $amount = min($amount, $max_raise_amount_by);
        $amount = max($amount, $min_raise_amount_by);
        $amount = max($amount, $this->last_raise_amount);
        $amount = min($amount, $seat->get_stack()->get_amount());
        $seat->bet += $amount;
        $seat->total_bet += $amount;
        $amount = min($amount, $seat->get_stack()->get_amount());
        $this->pots[count($this->pots) - 1]->contribute($amount, $seat);
        $this->chat($seat->get_player()->get_name() . " calls $" . number_format($amount, 2, '.', ','));
        if ($seat->get_stack()->get_amount() <= 0) {
            $seat->set_status(SeatStatus::ALLIN);
            $this->chat($seat->get_player()->get_name() . " is ALL-IN!");
        } else $seat->set_status(SeatStatus::CALLED);
        $this->check_table_all_in();
    }
    public function raise_by(Seat $seat, $amount): void
    {
        echo ("\r                                                                                          \r");
        extract($this->get_min_max($seat));
        $amount = min($amount, $max_raise_amount_by);
        $amount = max($amount, $min_raise_amount_by);
        $amount = max($amount, $this->last_raise_amount);
        $amount = min($amount, $seat->get_stack()->get_amount());
        $amount = $this->bet + $amount - $seat->bet;
        $seat->bet += $amount;
        $seat->total_bet += $amount;
        $this->pots[count($this->pots) - 1]->contribute($amount, $seat);
        $this->last_raise_amount = (float)$seat->bet - (float)$this->bet;
        $this->bet = $seat->bet;
        $this->chat($seat->get_player()->get_name() . " raises it to $" . number_format($seat->bet, 2, '.', ',') . " total.");
        foreach ($this->seats as $other_seat) {
            if ($other_seat->get_status()->active()) $other_seat->set_status(SeatStatus::UPCOMING_ACTION);
        }
        if ($seat->get_stack()->get_amount() <= 0) {
            $seat->set_status(SeatStatus::ALLIN);
            $this->chat($seat->get_player()->get_name() . " is ALL-IN!");
        } else $seat->set_status(SeatStatus::RAISED);
        $this->check_table_all_in();
    }
    public function all_in(Seat $seat): void
    {
        echo ("\r                                                                                          \r");
        $amount = $seat->get_stack()->get_amount();
        $seat->bet += $seat->get_stack()->get_amount();
        $seat->total_bet += $seat->get_stack()->get_amount();
        $this->pots[count($this->pots) - 1]->contribute($seat->get_stack()->get_amount(), $seat);
        $this->bet = $seat->bet;
        if ($amount < $seat->bet) $this->chat($seat->get_player()->get_name() . " is all in for " . number_format($amount, 2, ".", ",") . " more, $" . number_format($seat->bet, 2, '.', ',') . " total.");
        else $this->chat($seat->get_player()->get_name() . " is all in for $" . number_format($seat->bet, 2, '.', ','));
        foreach ($this->seats as $other_seat) if ($other_seat->get_status()->active()) $other_seat->set_status(SeatStatus::UPCOMING_ACTION);
        $seat->set_status(SeatStatus::ALLIN);
        $this->check_table_all_in();
    }
    public function check_table_all_in()
    {
        $not_all_in = [];
        foreach ($this->seats as $seat) {
            if ($seat->status->active()) $not_all_in[] = $seat;
        }
        if (count($not_all_in) > 1) return;
        $this->config['status'] = TableStatus::ALLIN;
    }
    public function sit_out(Seat $seat): void
    {
        $this->fold($seat);
        $seat->set_status(SeatStatus::SITOUT);
        $this->chat($seat->get_player()->get_name() . " sits out.");
    }
    public function sit_in(Seat $seat): void
    {
        $seat->set_status(SeatStatus::PLAYING);
        $this->chat($seat->get_player()->get_name() . " sits in.");
    }
    public function timeout(Seat $seat): void
    {
        $this->fold($seat);
        $seat->set_status(SeatStatus::TIMEOUT);
        $this->chat($seat->get_player()->get_name() . " times out.");
    }
    private function all_pots_are_good(): bool
    {
        foreach ($this->seats as $seat) {
            if ($seat->status == SeatStatus::UPCOMING_ACTION) return false;
        }
        foreach ($this->pots as $pot) {
                        $contributions = [];
            foreach ($pot->eligible as $seat) {
                $contributions[] = $seat["contributed"];
            }
            if (count(array_unique($contributions)) !== 1) {
                return false;
            }
        }
        return true;
    }
    private function get_action_order(): array
    {
        $action_order = [];
        $seat_number = $this->action_position;
        while (true) {
            $seat_number++;
            if ($seat_number > count($this->seats)) $seat_number = 1;
            $seat = $this->seats[$seat_number];
            if ($seat->get_status()->active()) {
                $action_order[] = $seat_number;
            }
            if ($seat_number == $this->action_position) break;
        }
        return $action_order;
    }
    private function deal_cards(): void
    {
        $action_order = $this->get_action_order();
        for ($i = 0; $i < $this->config["GameType"]->num_hole_cards(); $i++) {
            foreach ($action_order as $seat_number) {
                $this->deck->deal_card($this->seats[$seat_number]->cards);
            }
        }
    }
    private function post_blinds(): int
    {
        return $this->post_big_blind($this->post_small_blind());
    }
    private function post_small_blind(): int
    {
        $small_blind_amount = $this->config['smallBlind'];
        $small_blind_seat_number = $this->get_next_active_seat($this->button_position);
        $small_blind_seat = $this->seats[$small_blind_seat_number];
        $small_blind_amount = min($small_blind_amount, $small_blind_seat->get_stack()->get_amount());
        while ($small_blind_seat->get_stack()->get_amount() < $small_blind_amount) {
            $small_blind_seat->set_status(SeatStatus::SITOUT);
            $small_blind_seat_number = $this->get_next_active_seat($this->button_position);
            $small_blind_seat = $this->seats[$small_blind_seat_number];
        }
        $this->pots[count($this->pots) - 1]->contribute($small_blind_amount, $small_blind_seat);
        $small_blind_seat->set_status(SeatStatus::UPCOMING_ACTION);
        if ($small_blind_seat->get_stack()->get_amount() === 0) $small_blind_seat->set_status(SeatStatus::ALLIN);
        $small_blind_seat->bet = $this->config['smallBlind'];
        $small_blind_seat->total_bet = $this->config['smallBlind'];
        $this->bet = $this->config['smallBlind'];
        $this->last_raise_amount = $this->config['smallBlind'];
        $this->chat($small_blind_seat->get_player()->get_name() . " posts the small blind of $" . $small_blind_amount);
        return $small_blind_seat_number;
    }
    private function post_big_blind($small_blind_seat_number): int
    {
        $big_blind_amount = $this->config['bigBlind'];
        $big_blind_seat_number = $this->get_next_active_seat($small_blind_seat_number);
        $big_blind_seat = $this->seats[$big_blind_seat_number];
        $big_blind_amount = min($big_blind_amount, $big_blind_seat->get_stack()->get_amount());
        while ($big_blind_seat->get_stack()->get_amount() < $big_blind_amount) {
            $big_blind_seat->set_status(SeatStatus::SITOUT);
            $big_blind_seat_number = $this->get_next_active_seat($this->button_position + 2);
            $big_blind_seat = $this->seats[$big_blind_seat_number];
        }
        $this->pots[count($this->pots) - 1]->contribute($big_blind_amount, $big_blind_seat);
        $big_blind_seat->set_status(SeatStatus::UPCOMING_ACTION);
        if ($big_blind_seat->get_stack()->get_amount() === 0) $big_blind_seat->set_status(SeatStatus::ALLIN);
        $big_blind_seat->bet = $this->config['bigBlind'];
        $big_blind_seat->total_bet = $this->config['bigBlind'];
        $this->bet = $this->config['bigBlind'];
        $this->last_raise_amount = $this->config['bigBlind'] - $this->config['smallBlind'];
        $this->chat($big_blind_seat->get_player()->get_name() . " posts the big blind of $" . $big_blind_amount);
        return $big_blind_seat_number;
    }
    private function advance_button(): void
    {
                $this->button_position = $this->get_next_active_seat($this->button_position);
        $this->chat("The button is at seat " . $this->button_position . ". ({$this->seats[$this->button_position]->get_player()->get_name()})");
    }
    private function get_next_active_seat(int $seat_num): int
    {
        $seat_num++;
        if ($seat_num > count($this->seats)) $seat_num = 1;
        if (!$this->seats[$seat_num]->status->active()) $seat_num = $this->get_next_active_seat($seat_num);
        return $seat_num;
    }
    public function reset_seats(): int
    {
        $players_ready = 0;
        echo ("Seat\tOff Table\tOn Table  \tName\tRace\tStatus\n");
        foreach ($this->seats as $seat_number => $seat) {
            $seat->clear_cards();
            $seat->bet = 0;
            $seat->total_bet = 0;
                        switch ($seat->get_status()) {
                case SeatStatus::WAITING:
                case SeatStatus::POSTED:
                case SeatStatus::FOLDED:
                case SeatStatus::PLAYING:
                case SeatStatus::ALLIN:
                case SeatStatus::CALLED:
                case SeatStatus::RAISED:
                case SeatStatus::BET:
                case SeatStatus::CHECKED:
                case SeatStatus::UPCOMING_ACTION:
                    if ($seat->get_stack()->get_amount() <= 0) $seat->set_status(SeatStatus::BUSTED);
                    else {
                        $seat->set_status(SeatStatus::PLAYING);
                        $this->chat("$seat_number\t" .
                            "{$seat->get_player()->get_bankroll()}\t" .
                            "{$seat->get_stack()}\t" .
                            "{$seat->get_player()->get_name()}\t" .
                            "{$seat->get_player()->type->display()}\t" .
                            "{$seat->get_status()->display()}");
                        $players_ready++;
                        $this->pots[0]->eligible[$seat_number] = [
                            "seat" => $seat,
                            "contributed" => 0
                        ];
                    }
                    break;
                case SeatStatus::TIMEOUT:
                    $seat->set_status(SeatStatus::SITOUT);
                    $this->chat("$seat_number\t" .
                        "{$seat->get_player()->get_bankroll()}\t" .
                        "{$seat->get_stack()}\t" .
                        "{$seat->get_player()->get_name()}\t" .
                        "{$seat->get_player()->type}\t" .
                        "{$seat->get_status()->display()}");
                    break;
                default:
                    if (isset($seat->player)) {
                        $this->chat("$seat_number\t" .
                            "{$seat->get_player()->get_bankroll()}\t" .
                            "{$seat->get_stack()}\t" .
                            "{$seat->get_player()->get_name()}\t" .
                            "{$seat->get_player()->type}\t" .
                            "{$seat->get_status()->display()}");
                    } else {
                        $this->chat("$seat_number\t{$seat->get_status()->display()}");
                    }
                    break;
            }
        }
        return $players_ready;
    }
    public function chat($message)
    {
        $this->chat_history[] = ["message" => $message, "tokens" => count($this->encoder->encode($message))];
        echo ("\r                                                                                          \r");
        echo ($message . "\n");
    }
    public function get_chat_history(int $token_limit = 3596): array
    {
        $chat_history = [];
        $token_count = 0;
        foreach (array_reverse($this->chat_history) as $chat) {
            $token_count += $chat["tokens"];
            if ($token_count > $token_limit) break;
            $chat_history[] = $chat["message"];
        }
        return array_reverse($chat_history);
    }
}

$build_info = json_decode(file_get_contents('build_info.json'), true);
$version_number = implode(".", str_split($build_info["number"]));
if ($build_info["number"] < 100) $version_number = "0." . $version_number;
echo ("poker (cli) v$version_number (built: " . $build_info["date"] . ")\n");
$casino = new Casino("My Casino");
$player_names = [
    "Lily",
    "Adam",
    "Bella",
    "Ursula",
    "Finley",
    "Stella",
    "Derek",
    "Max",
    "Frank"
];
$tournament_blinds = [
    [10, 20],
    [15, 30],
    [20, 40],
    [25, 50],
    [30, 60],
    [40, 80],
    [50, 100],
    [60, 120],
    [75, 150],
    [100, 200],
    [125, 250],
    [150, 300],
    [200, 400],
    [250, 500],
    [300, 600],
    [400, 800],
    [500, 1000],
    [600, 1200],
    [800, 1600],
    [1000, 2000],
    [1200, 2400],
    [1500, 3000],
    [2000, 4000],
    [2500, 5000],
    [3000, 6000],
    [4000, 8000],
    [5000, 10000],
    [6000, 12000],
    [8000, 16000],
    [10000, 20000],
    [12000, 24000],
    [15000, 30000],
    [20000, 40000],
    [25000, 50000],
    [30000, 60000],
    [40000, 80000],
    [50000, 100000],
    [60000, 120000],
    [80000, 160000],
    [100000, 200000],
    [120000, 240000],
    [150000, 300000],
    [200000, 400000],
    [250000, 500000],
    [300000, 600000],
    [400000, 800000],
    [500000, 1000000],
    [600000, 1200000],
    [800000, 1600000],
    [1000000, 2000000],
    [1200000, 2400000],
    [1500000, 3000000],
    [2000000, 4000000],
    [2500000, 5000000],
    [3000000, 6000000],
    [4000000, 8000000],
    [5000000, 10000000],
    [6000000, 12000000],
    [8000000, 16000000],
    [10000000, 20000000],
    [12000000, 24000000],
    [15000000, 30000000],
    [20000000, 40000000],
    [25000000, 50000000],
    [30000000, 60000000],
    [40000000, 80000000],
];
$table = $casino->add_table(new Table([
    "id" => 1,
    "name" => "SnG 1",
    "seats" => 6,
    "minBuyIn" => 1500,
    "maxBuyIn" => 1500,
]));
for ($i = 0; $i < $table->config["seats"]; $i++) {
    $players[$i] = $casino->add_player(new Player($player_names[$i], PlayerType::AI));
    $casino->buy_chips($players[$i], 1500);
    $table->seat_player($players[$i], $table->seats[$i + 1])->buy_chips(1500);
}
$blind_index = -1;
while (true) {
    $blind_index++;
    if ($blind_index > count($tournament_blinds) - 1) $blind_index = count($tournament_blinds) - 1;
        for ($hands = 0; $hands < 9; $hands++) {
        $table->config["smallBlind"] = $tournament_blinds[$blind_index][0];
        $table->config["bigBlind"] = $tournament_blinds[$blind_index][1];
        $table->new_hand();
    }
}
