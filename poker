#!/usr/local/bin/php -f
<?php

namespace RPurinton\poker;

class Card
{
    public function __construct(
        private Suit $suit,
        private Rank $rank
    ) {
    }
    public function getSuit(): Suit
    {
        return $this->suit;
    }
    public function getRank(): Rank
    {
        return $this->rank;
    }
    public function __toString(): string
    {
        return $this->rank->display() . $this->suit->display();
    }
}

class Casino
{
    public array $tables = [];
    public array $players = [];
    public Pot $vault;
    public function __construct(
        private string $name
    ) {
        $this->vault = new Pot(0);
    }
    public function __toString(): string
    {
        return $this->name;
    }
    public function getName(): string
    {
        return $this->name;
    }
    public function setName(string $name): void
    {
        if (strlen($name) < 3) {
            throw new \Exception('Name must be at least 3 characters.');
        }
        $this->name = $name;
    }
    public function addTable(Table $table): Table
    {
        $this->tables[] = $table;
        return $table;
    }
    public function addPlayer(Player $player): Player
    {
        $this->players[] = $player;
        return $player;
    }
    public function depositToVault(float $amount): void
    {
        $this->vault->add($amount);
    }
    public function withdrawFromVault(float $amount): void
    {
        $this->vault->remove($amount);
    }
    public function buyChips(Player $player, float $amount): void
    {
        $this->depositToVault($amount);
        $player->getBankroll()->add($amount);
    }
    public function cashOut(Player $player): void
    {
        $this->withdrawFromVault($player->getBankroll()->getAmount());
        $player->getBankroll()->setAmount(0);
    }
    public function cashOutPartial(Player $player, float $amount): void
    {
        $this->withdrawFromVault($amount);
        $player->getBankroll()->remove($amount);
    }
}

class Deck
{
    private $cards = [];
    public function __construct()
    {
        $this->cards = $this->createDeck();
    }
    public function getCards()
    {
        return $this->cards;
    }
    public function shuffle()
    {
        shuffle($this->cards);
    }
    public function cut()
    {
        $cut = rand(1, 51);
        $this->cards = array_merge(
            array_slice($this->cards, $cut),
            array_slice($this->cards, 0, $cut)
        );
    }
    public function dealCard(array &$destination): void
    {
        $destination[] = array_pop($this->cards);
    }
    private function createDeck()
    {
        $cards = [];
        foreach (Suit::toArray() as $suit) {
            foreach (Rank::toArray() as $rank) {
                $cards[] = new Card($suit, $rank);
            }
        }
        return $cards;
    }
    public function toString()
    {
        $deck = '';
        foreach ($this->cards as $card) {
            $deck .= $card . ' ';
        }
        return $deck;
    }
}

enum TableStatus: int
{
    case WAITING_FOR_PLAYERS = 0;
    case STARTING = 1;
    case PREFLOP = 2;
    case FLOP = 3;
    case TURN = 4;
    case RIVER = 5;
    case SHOWDOWN = 6;
    case HAND_OVER = 7;
    public function display(): string
    {
        return match ($this) {
            TableStatus::WAITING_FOR_PLAYERS => 'Waiting for players',
            TableStatus::STARTING => 'Starting',
            TableStatus::PREFLOP => 'Pre-flop',
            TableStatus::FLOP => 'Flop',
            TableStatus::TURN => 'Turn',
            TableStatus::RIVER => 'River',
            TableStatus::SHOWDOWN => 'Showdown',
            TableStatus::HAND_OVER => 'Hand over',
        };
    }
}

enum PlayerStatus
{
    case STANDING;
    case WAITING_FOR_TABLE;
    case SEAT_RESERVED;
    case SEATED;
}

enum Suit
{
    case CLUBS;
    case DIAMONDS;
    case HEARTS;
    case SPADES;
    public function display(): string
    {
        return match ($this) {
            Suit::CLUBS => 'c',
            Suit::DIAMONDS => 'd',
            Suit::HEARTS => 'h',
            Suit::SPADES => 's',
        };
    }
    public function display_long(): string
    {
        return match ($this) {
            Suit::CLUBS => 'Club',
            Suit::DIAMONDS => 'Diamond',
            Suit::HEARTS => 'Heart',
            Suit::SPADES => 'Spade',
        };
    }
    public static function toArray(): array
    {
        return [
            Suit::CLUBS,
            Suit::DIAMONDS,
            Suit::HEARTS,
            Suit::SPADES,
        ];
    }
}

enum PlayerType
{
    case HUMAN;
    case BOT;
}

enum SeatStatus
{
    case EMPTY;
    case RESERVED;
    case WAITING;
    case POSTED;
    case PLAYING;
    case SITOUT;
    case TIMEOUT;
    case FOLDED;
}

enum Limit
{
    case NL;
    case PL;
    case FL;
    public function display(): string
    {
        return match ($this) {
            Limit::NL => 'No Limit',
            Limit::PL => 'Pot Limit',
            Limit::FL => 'Fixed Limit',
        };
    }
    public static function toArray(): array
    {
        return [
            Limit::NL,
            Limit::PL,
            Limit::FL,
        ];
    }
}

enum Rank: int
{
    case TWO = 2;
    case THREE = 3;
    case FOUR = 4;
    case FIVE = 5;
    case SIX = 6;
    case SEVEN = 7;
    case EIGHT = 8;
    case NINE = 9;
    case TEN = 10;
    case JACK = 11;
    case QUEEN = 12;
    case KING = 13;
    case ACE = 14;
    public function display(): string
    {
        return match ($this) {
            self::TWO => '2',
            self::THREE => '3',
            self::FOUR => '4',
            self::FIVE => '5',
            self::SIX => '6',
            self::SEVEN => '7',
            self::EIGHT => '8',
            self::NINE => '9',
            self::TEN => 'T',
            self::JACK => 'J',
            self::QUEEN => 'Q',
            self::KING => 'K',
            self::ACE => 'A',
        };
    }
    public function display_long(): string
    {
        return match ($this) {
            self::TWO => 'Two',
            self::THREE => 'Three',
            self::FOUR => 'Four',
            self::FIVE => 'Five',
            self::SIX => 'Six',
            self::SEVEN => 'Seven',
            self::EIGHT => 'Eight',
            self::NINE => 'Nine',
            self::TEN => 'Ten',
            self::JACK => 'Jack',
            self::QUEEN => 'Queen',
            self::KING => 'King',
            self::ACE => 'Ace',
        };
    }
    public function numeric(): int
    {
        return match ($this) {
            self::TWO => 2,
            self::THREE => 3,
            self::FOUR => 4,
            self::FIVE => 5,
            self::SIX => 6,
            self::SEVEN => 7,
            self::EIGHT => 8,
            self::NINE => 9,
            self::TEN => 10,
            self::JACK => 11,
            self::QUEEN => 12,
            self::KING => 13,
            self::ACE => 14,
        };
    }
    public static function toArray(): iterable
    {
        return [
            self::TWO,
            self::THREE,
            self::FOUR,
            self::FIVE,
            self::SIX,
            self::SEVEN,
            self::EIGHT,
            self::NINE,
            self::TEN,
            self::JACK,
            self::QUEEN,
            self::KING,
            self::ACE,
        ];
    }
}

enum GameType: int
{
    case TEXAS_HOLDEM = 1;
    case OMAHA = 2;
    case OMAHA_HILO = 3;
    public function display()
    {
        return match ($this) {
            GameType::TEXAS_HOLDEM => 'Texas Hold \'Em',
            GameType::OMAHA => 'Omaha',
            GameType::OMAHA_HILO => 'Omaha Hi/Lo',
        };
    }
    public function num_hole_cards()
    {
        return match ($this) {
            GameType::TEXAS_HOLDEM => 2,
            GameType::OMAHA, GameType::OMAHA_HILO => 4,
        };
    }
}

class HandEvaluator
{
    public function __construct(private GameType $GameType)
    {
    }
    public function setGameType(GameType $GameType): void
    {
        $this->GameType = $GameType;
    }
    public function hand_toString(array $holeCards, array $communityCards): string
    {
        switch ($this->GameType) {
            case GameType::TEXAS_HOLDEM:
                return $this->hand_toString_texas($this->get_combos_texas($holeCards, $communityCards));
            default:
                return "Unknown Game Type";
        }
    }
    public function hand_toString_texas(array $combos): string
    {
        if (StraightFlush::is($combos)) return StraightFlush::toString($combos);
        if (FourofaKind::is($combos)) return FourofaKind::toString($combos);
        if (FullHouse::is($combos)) return FullHouse::toString($combos);
        if (Flush::is($combos)) return Flush::toString($combos);
        if (Straight::is($combos)) return Straight::toString($combos);
        if (ThreeofaKind::is($combos)) return ThreeofaKind::toString($combos);
        if (TwoPair::is($combos)) return TwoPair::toString($combos);
        if (Pair::is($combos)) return Pair::toString($combos);
        return HighCard::toString($combos);
    }
    public function hand_toRank(array $combos): int
    {
        if (StraightFlush::is($combos)) return 8;
        if (FourofaKind::is($combos)) return 7;
        if (FullHouse::is($combos)) return 6;
        if (Flush::is($combos)) return 5;
        if (Straight::is($combos)) return 4;
        if (ThreeofaKind::is($combos)) return 3;
        if (TwoPair::is($combos)) return 2;
        if (Pair::is($combos)) return 1;
        return 0;
    }
    public function hand_get_best_combo1(array $combos)
    {
        if (StraightFlush::is($combos)) return StraightFlush::best(StraightFlush::possibles($combos));
        if (FourofaKind::is($combos)) return FourofaKind::best(FourofaKind::possibles($combos));
        if (FullHouse::is($combos)) return FullHouse::best(FullHouse::possibles($combos));
        if (Flush::is($combos)) return Flush::best(Flush::possibles($combos));
        if (Straight::is($combos)) return Straight::best(Straight::possibles($combos));
        if (ThreeofaKind::is($combos)) return ThreeofaKind::best(ThreeofaKind::possibles($combos));
        if (TwoPair::is($combos)) return TwoPair::best(TwoPair::possibles($combos));
        if (Pair::is($combos)) return Pair::best(Pair::possibles($combos));
        return HighCard::best(HighCard::possibles($combos));
    }
    public function hand_get_best_combo2(array $best): array
    {
        foreach ($best as $hand) return $hand["hand"];
    }
    public function get_winner_indexes(array $hands, array $communityCards): array
    {
        switch ($this->GameType) {
            case GameType::TEXAS_HOLDEM:
                return $this->get_winner_indexes_texas($hands, $communityCards);
            default:
                return [];
        }
    }
    public function get_winner_indexes_texas(array $hands, array $communityCards): array
    {
        $high_rank = 0;
        foreach ($hands as $index => $hand) {
            $hands[$index]["combos"] = $this->get_combos_texas($hand, $communityCards);
            $hands[$index]["rank"] = $this->hand_toRank($hands[$index]["combos"]);
            $hands[$index]["best_combo"] = $this->hand_get_best_combo2(($this->hand_get_best_combo1($hands[$index]["combos"])));
            if ($hands[$index]["rank"] > $high_rank) $high_rank = $hands[$index]["rank"];
        }
        foreach ($hands as $index => $hand) {
            if ($hand["rank"] < $high_rank) unset($hands[$index]);
        }
        if (count($hands) < 2) return array_keys($hands);
        foreach ($hands as $index => $hand) $contenders[$index] = $hand["best_combo"];
        switch ($high_rank) {
            case 8:
                $best = StraightFlush::best(StraightFlush::possibles($contenders));
                break;
            case 7:
                $best = FourofaKind::best(FourofaKind::possibles($contenders));
                break;
            case 6:
                $best = FullHouse::best(FullHouse::possibles($contenders));
                break;
            case 5:
                $best = Flush::best(Flush::possibles($contenders));
                break;
            case 4:
                $best = Straight::best(Straight::possibles($contenders));
                break;
            case 3:
                $best = ThreeofaKind::best(ThreeofaKind::possibles($contenders));
                break;
            case 2:
                $best = TwoPair::best(TwoPair::possibles($contenders));
                break;
            case 1:
                $best = Pair::best(Pair::possibles($contenders));
                break;
            default:
                $best = HighCard::best(HighCard::possibles($contenders));
        }
        return array_keys($best);
    }
    private function get_combos_texas(array $holeCards, array $communityCards): array
    {
                switch (count($communityCards)) {
            case 0:
                return [$this->sort($holeCards)];
            case 3:
                return [$this->sort(array_merge($holeCards, $communityCards))];
            case 4:
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                return $combos;
            case 5:
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[1], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[0], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $holeCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[0], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[0], $communityCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[3]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[2], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[1], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[0], $communityCards[2], $communityCards[3], $communityCards[4]]);
                $combos[] = $this->sort([$holeCards[1], $communityCards[1], $communityCards[2], $communityCards[3], $communityCards[4]]);
                return $combos;
        }
    }
    private function sort(array $combo)
    {
                usort($combo, function ($a, $b) {
            return $a->getRank()->numeric() - $b->getRank()->numeric();
        });
        return $combo;
    }
}

class Player
{
    private PlayerStatus $status = PlayerStatus::STANDING;
    private ?Pot $bankroll;
    public function __construct(
        private string $name,
        public PlayerType $type = PlayerType::HUMAN
    ) {
        $this->bankroll = new Pot(0);
    }
    public function getName(): string
    {
        return $this->name;
    }
    public function getBankroll(): Pot
    {
        return $this->bankroll;
    }
    public function setBankroll(Pot $bankroll): void
    {
        $this->bankroll = $bankroll;
    }
    public function setStatus(PlayerStatus $status): void
    {
        $this->status = $status;
    }
    public function __toString(): string
    {
        return $this->name;
    }
}

class Pair
{
    public static function is(array $combos): bool
    {
        if (count($combos) === 1) foreach ($combos as $combo) if (count($combo) === 2) {
            return $combo[0]->getRank()->numeric() === $combo[1]->getRank()->numeric();
        }
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            if (count($combo) === 2) {
                if ($combo[0]->getRank()->numeric() === $combo[1]->getRank()->numeric()) {
                    return [
                        [
                            "hand" => $combo,
                            "main" => $combo[0]->getRank()->numeric(),
                            "display" => "PAIR of " . $combo[0]->getRank()->display_long() . "s [" . implode("] [", $combo) . "]"
                        ]
                    ];
                }
            }
            $pair_string = "";
            foreach ($combo as $card) {
                $pair_string .= $card->getRank()->display();
            }
            if ($pair_string[0] === $pair_string[1]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main" => $combo[0]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "kicker3" => $combo[2]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[1] === $pair_string[2]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main" => $combo[1]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[1]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[2] === $pair_string[3]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main" => $combo[2]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[1]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[2]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($pair_string[3] === $pair_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main" => $combo[3]->getRank()->numeric(),
                    "kicker1" => $combo[2]->getRank()->numeric(),
                    "kicker2" => $combo[1]->getRank()->numeric(),
                    "kicker3" => $combo[0]->getRank()->numeric(),
                    "display" => "PAIR of " . $combo[3]->getRank()->display_long() . "s (" . $combo[2]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        foreach ($possibles as $possible) {
            if ($possible["main"] > $best_main) {
                $best_main = $possible["main"];
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
            }
            if ($possible["main"] == $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class ThreeofaKind
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $tok_string = "";
            foreach ($combo as $card) {
                $tok_string .= $card->getRank()->display();
            }
            if ($tok_string[0] === $tok_string[1] && $tok_string[1] === $tok_string[2]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[3]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . "/" . $combo[3]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tok_string[1] === $tok_string[2] && $tok_string[2] === $tok_string[3]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[1]->getRank()->numeric(),
                    "kicker1" => $combo[4]->getRank()->numeric(),
                    "kicker2" => $combo[0]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[1]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . "/" . $combo[0]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tok_string[2] === $tok_string[3] && $tok_string[3] === $tok_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[2]->getRank()->numeric(),
                    "kicker1" => $combo[1]->getRank()->numeric(),
                    "kicker2" => $combo[0]->getRank()->numeric(),
                    "display" => "THREE-OF-A-KIND " . $combo[2]->getRank()->display_long() . "s (" . $combo[1]->getRank()->display_long() . "/" . $combo[0]->getRank()->display_long() . " kickers) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class TwoPair
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $tp_string = "";
            foreach ($combo as $card) {
                $tp_string .= $card->getRank()->display();
            }
            if ($tp_string[0] === $tp_string[1] && $tp_string[2] === $tp_string[3]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main1" => $combo[2]->getRank()->numeric(),
                    "main2" => $combo[0]->getRank()->numeric(),
                    "kicker" => $combo[4]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[2]->getRank()->display_long() . "s over " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tp_string[0] === $tp_string[1] && $tp_string[3] === $tp_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main1" => $combo[3]->getRank()->numeric(),
                    "main2" => $combo[0]->getRank()->numeric(),
                    "kicker" => $combo[2]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[3]->getRank()->display_long() . "s over " . $combo[0]->getRank()->display_long() . "s (" . $combo[2]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($tp_string[1] === $tp_string[2] && $tp_string[3] === $tp_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main1" => $combo[3]->getRank()->numeric(),
                    "main2" => $combo[1]->getRank()->numeric(),
                    "kicker" => $combo[0]->getRank()->numeric(),
                    "display" => "TWO-PAIR " . $combo[3]->getRank()->display_long() . "s over " . $combo[1]->getRank()->display_long() . "s (" . $combo[0]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main1 = 0;
        $best_main2 = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main1"] > $best_main1) {
                $best_main1 = $possible["main1"];
                $best_main2 = $possible["main2"];
                $best_kicker = $possible["kicker"];
            }
            if ($possible["main1"] === $best_main1 && $possible["main2"] > $best_main2) {
                $best_main2 = $possible["main2"];
                $best_kicker = $possible["kicker"];
            }
            if ($possible["main1"] === $best_main1 && $possible["main2"] === $best_main2 && $possible["kicker"] > $best_kicker) {
                $best_kicker = $possible["kicker"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main1"] === $best_main1 && $possible["main2"] === $best_main2 && $possible["kicker"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Flush
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $flush_string = "";
            foreach ($combo as $card) {
                $flush_string .= $card->getSuit()->display();
            }
            $flush = false;
            if ($flush_string == "ccccc") $flush = true;
            if ($flush_string == "ddddd") $flush = true;
            if ($flush_string == "hhhhh") $flush = true;
            if ($flush_string == "sssss") $flush = true;
            if ($flush) $possibles[] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "kicker2" => $combo[3]->getRank()->numeric(),
                "kicker3" => $combo[2]->getRank()->numeric(),
                "kicker4" => $combo[1]->getRank()->numeric(),
                "kicker5" => $combo[0]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . " high FLUSH [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        $best_kicker4 = 0;
        $best_kicker5 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] > $best_kicker4) {
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] > $best_kicker5) {
                $best_kicker5 = $possible["kicker5"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] === $best_kicker5) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Straight
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $straight_string = "";
            foreach ($combo as $card) {
                $straight_string .= $card->getRank()->display();
            }
            $flush = false;
            $straight = false;
            if ($straight_string == "2345A") $straight = true;
            if ($straight_string == "23456") $straight = true;
            if ($straight_string == "34567") $straight = true;
            if ($straight_string == "45678") $straight = true;
            if ($straight_string == "56789") $straight = true;
            if ($straight_string == "6789T") $straight = true;
            if ($straight_string == "789TJ") $straight = true;
            if ($straight_string == "89TJQ") $straight = true;
            if ($straight_string == "9TJQK") $straight = true;
            if ($straight_string == "TJQKA") $straight = true;
            if ($flush && $straight) $possibles[] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . "high STRAIGHT [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class FourofaKind
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $fok_string = "";
            foreach ($combo as $card) {
                $fok_string .= $card->getRank()->display();
            }
            if ($fok_string[0] === $fok_string[1] && $fok_string[1] === $fok_string[2] && $fok_string[2] === $fok_string[3]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker_rank" => $combo[4]->getRank()->numeric(),
                    "display" => "FOUR-OF-A-KIND " . $combo[0]->getRank()->display_long() . "s (" . $combo[4]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
            if ($fok_string[1] === $fok_string[2] && $fok_string[2] === $fok_string[3] && $fok_string[3] === $fok_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[1]->getRank()->numeric(),
                    "kicker_rank" => $combo[0]->getRank()->numeric(),
                    "display" => "FOUR-OF-A-KIND " . $combo[1]->getRank()->display_long() . "s (" . $combo[0]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker = $possible["kicker_rank"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class StraightFlush
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $straight_string = "";
            foreach ($combo as $card) {
                $straight_string .= $card->getRank()->display();
            }
            $flush_string = "";
            foreach ($combo as $card) {
                $flush_string .= $card->getSuit()->display();
            }
            $flush = false;
            if ($flush_string == "ccccc") $flush = true;
            if ($flush_string == "ddddd") $flush = true;
            if ($flush_string == "hhhhh") $flush = true;
            if ($flush_string == "sssss") $flush = true;
            $straight = false;
            if ($straight_string == "2345A") $straight = true;
            if ($straight_string == "23456") $straight = true;
            if ($straight_string == "34567") $straight = true;
            if ($straight_string == "45678") $straight = true;
            if ($straight_string == "56789") $straight = true;
            if ($straight_string == "6789T") $straight = true;
            if ($straight_string == "789TJ") $straight = true;
            if ($straight_string == "89TJQ") $straight = true;
            if ($straight_string == "9TJQK") $straight = true;
            if ($straight_string == "TJQKA") $straight = true;
            if ($flush && $straight) $possibles[] = [
                "hand" => $combo,
                "kicker_rank" => $combo[4]->getRank()->numeric()
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $hand) {
            $hand = $hand["hand"];
            $high_card = $hand[4]->getRank()->display_long();
            $suit = $hand[4]->getSuit()->display_long();
            if ($high_card === "Ace") {
                return "ROYAL FLUSH of $suit [" . implode("] [", $hand) . "]";
            }
            return "$high_card high STRAIGHT FLUSH of $suit [" . implode("] [", $hand) . "]";
        }
    }
}

class FullHouse
{
    public static function is(array $combos): bool
    {
        if ((count($combos) === 1) && count($combos[0]) === 2) return false;
        return count(self::possibles($combos)) > 0;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            $fh_string = "";
            foreach ($combo as $card) {
                $fh_string .= $card->getRank()->display();
            }
            if ($fh_string[0] === $fh_string[1] && $fh_string[1] === $fh_string[2] && $fh_string[3] === $fh_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[0]->getRank()->numeric(),
                    "kicker_rank" => $combo[4]->getRank()->numeric(),
                    "display" => "FULL HOUSE " . $combo[0]->getRank()->display_long() . "s of " . $combo[4]->getRank()->display_long() . "s [" . implode("] [", $combo) . "]"
                ];
            }
            if ($fh_string[0] === $fh_string[1] && $fh_string[2] === $fh_string[3] && $fh_string[3] === $fh_string[4]) {
                $possibles[] = [
                    "hand" => $combo,
                    "main_rank" => $combo[4]->getRank()->numeric(),
                    "kicker_rank" => $combo[0]->getRank()->numeric(),
                    "display" => "FULL HOUSE " . $combo[4]->getRank()->display_long() . "s of " . $combo[0]->getRank()->display_long() . "s [" . implode("] [", $combo) . "]"
                ];
            }
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_main = 0;
        $best_kicker = 0;
        foreach ($possibles as $possible) {
            if ($possible["main_rank"] > $best_main) {
                $best_main = $possible["main_rank"];
                $best_kicker = $possible["kicker_rank"];
            }
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] > $best_kicker) {
                $best_kicker = $possible["kicker_rank"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["main_rank"] === $best_main && $possible["kicker_rank"] === $best_kicker) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class HighCard
{
    public static function is(array $combos): bool
    {
                return true;
    }
    public static function possibles(array $combos): array
    {
        $possibles = [];
        foreach ($combos as $combo) {
            if (count($combo) === 2) {
                return [
                    [
                        "hand" => $combo,
                        "kicker1" => $combo[1]->getRank()->numeric(),
                        "kicker2" => $combo[0]->getRank()->numeric(),
                        "display" => $combo[1]->getRank()->display_long() . " HIGH (" . $combo[0]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
                    ]
                ];
            }
            $possibles[] = [
                "hand" => $combo,
                "kicker1" => $combo[4]->getRank()->numeric(),
                "kicker2" => $combo[3]->getRank()->numeric(),
                "kicker3" => $combo[2]->getRank()->numeric(),
                "kicker4" => $combo[1]->getRank()->numeric(),
                "kicker5" => $combo[0]->getRank()->numeric(),
                "display" => $combo[4]->getRank()->display_long() . " HIGH (" . $combo[3]->getRank()->display_long() . " kicker) [" . implode("] [", $combo) . "]"
            ];
        }
        return $possibles;
    }
    public static function best(array $possibles): array
    {
        if (count($possibles) === 0) return [];
        if (count($possibles) === 1) foreach ($possibles as $index => $possible) return [$index => $possible];
        $best_kicker1 = 0;
        $best_kicker2 = 0;
        $best_kicker3 = 0;
        $best_kicker4 = 0;
        $best_kicker5 = 0;
        foreach ($possibles as $possible) {
            if ($possible["kicker1"] > $best_kicker1) {
                $best_kicker1 = $possible["kicker1"];
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] > $best_kicker2) {
                $best_kicker2 = $possible["kicker2"];
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] > $best_kicker3) {
                $best_kicker3 = $possible["kicker3"];
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] > $best_kicker4) {
                $best_kicker4 = $possible["kicker4"];
                $best_kicker5 = $possible["kicker5"];
            }
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] > $best_kicker5) {
                $best_kicker5 = $possible["kicker5"];
            }
        }
        $best = [];
        foreach ($possibles as $index => $possible) {
            if ($possible["kicker1"] === $best_kicker1 && $possible["kicker2"] === $best_kicker2 && $possible["kicker3"] === $best_kicker3 && $possible["kicker4"] === $best_kicker4 && $possible["kicker5"] === $best_kicker5) {
                $best[$index] = $possible;
            }
        }
        return $best;
    }
    public static function toString(array $combos): string
    {
        $best = self::best(self::possibles($combos));
        foreach ($best as $combo) return $combo["display"];
    }
}

class Pot
{
    public array $eligible = [];
    public function __construct(private float $amount = 0, public bool $good = true)
    {
        $this->amount = round($this->amount, 2);
    }
    public function add(float $amount): void
    {
        $this->amount += round($amount, 2);
    }
    public function remove(float $amount): void
    {
        $this->amount -= round($amount, 2);
    }
    public function getAmount(): float
    {
        return round($this->amount, 2);
    }
    public function setAmount(float $amount): void
    {
        $this->amount = round($amount, 2);
    }
    public function contribute(float $amount, Seat $seat)
    {
        $this->add($amount);
        $seat->getStack()->remove($amount);
        $this->eligible[$seat->seat_num] = $seat;
    }
    public function payout(array $winner_indexes, string $display_name): array
    {
        $results = [];
        $amount = round($this->amount / count($winner_indexes), 2);
        foreach ($winner_indexes as $index) {
            $results[] = $this->eligible[$index]->getPlayer()->getName() . " wins $" . number_format($amount, 2, '.', ',') . " from " . $display_name;
            $this->eligible[$index]->getStack()->add($amount);
            $this->remove($amount);
        }
        if ($this->amount) {
            $results[] = "The extra $" . number_format($this->amount, 2, '.', ',') . " goes to " . $this->eligible[$index]->getPlayer()->getName();
            $this->eligible[$index]->getStack()->add($this->amount);
            $this->remove($this->amount);
        }
        return $results;
    }
    public function __toString(): string
    {
        return '$' . number_format($this->amount, 2, '.', ',');
    }
}

class Seat
{
    private SeatStatus $status = SeatStatus::EMPTY;
    private ?Player $player = null;
    public array $cards = [];
    private Pot $stack;
    public float $bet = 0;
    public function __construct(public int $seat_num)
    {
        $this->stack = new Pot(0);
    }
    public function getStatus(): SeatStatus
    {
        return $this->status;
    }
    public function setStatus(SeatStatus $status): void
    {
        $this->status = $status;
    }
    public function getPlayer(): ?Player
    {
        return $this->player;
    }
    public function setPlayer(Player $player): void
    {
        $this->player = $player;
    }
    public function getStack(): Pot
    {
        return $this->stack;
    }
    public function __toString(): string
    {
        return $this->player->getName();
    }
    public function clearCards(): void
    {
        $this->cards = [];
    }
    public function buyChips(float $amount): void
    {
        $amount = min($amount, $this->player->getBankroll()->getAmount());
        $this->player->getBankroll()->remove($amount);
        $this->stack->add($amount);
    }
    public function topUp(float $amount): void
    {
        $current_stack = $this->stack->getAmount();
        if ($current_stack < $amount) {
            $this->buyChips($amount - $current_stack);
        }
    }
    public function prompt(Table $table): void
    {
        switch ($this->player->type) {
            case PlayerType::HUMAN:
                                echo ($this->player->getName() . "\t" . $table->HandEvaluator->hand_toString($this->cards, $table->communityCards) . "\n");
                break;
            case PlayerType::BOT:
                                echo ($this->player->getName() . "\t" . $table->HandEvaluator->hand_toString($this->cards, $table->communityCards) . "\n");
                break;
        }
    }
}

class Table
{
    public array $seats = [];
    private array $config = [
        "id" => null,
        "status" => TableStatus::WAITING_FOR_PLAYERS,
        "GameType" => GameType::TEXAS_HOLDEM,
        "seats" => 9,
        "smallBlind" => 1,
        "bigBlind" => 2,
        "limit" => Limit::NL,
        "minBuyIn" => 100,
        "maxBuyIn" => 1000,
        "straddles" => 0,
        "buttonstraddle" => false,
        "straddleAmount" => 4,
    ];
    public ?Deck $deck = null;
    public array $pots = [];
    public array $communityCards = [];
    public array $muck = [];
    public HandEvaluator $HandEvaluator;
    private int $button_position = 0;
    private int $action_position = 0;
    public array $chat_history = [];
    private $hand_count = 0;
    private $bet = 0;
    public function __construct(array $config = [])
    {
        $this->config = array_merge($this->config, $config);
        $this->createSeats();
        $this->deck = new Deck();
        $this->HandEvaluator = new HandEvaluator($this->config["GameType"]);
    }
    public function getSeats(): array
    {
        return $this->seats;
    }
    public function getGameType(): ?GameType
    {
        return $this->config['GameType'];
    }
    public function setGameType(GameType $GameType): void
    {
        $this->config['GameType'] = $GameType;
    }
    public function getConfig(): array
    {
        return $this->config;
    }
    public function setConfig(array $config): void
    {
        $this->config = array_merge($this->config, $config);
    }
    private function createSeats(): void
    {
        for ($i = 0; $i < $this->config['seats']; $i++) {
            $this->seats[$i] = new Seat($i);
        }
    }
    public function setStakes($minBuyIn, $maxBuyIn, $smallBlind, $bigBlind): void
    {
        $this->config['minBuyIn'] = $minBuyIn;
        $this->config['maxBuyIn'] = $maxBuyIn;
        $this->config['smallBlind'] = $smallBlind;
        $this->config['bigBlind'] = $bigBlind;
    }
    public function seatPlayer(Player $player, Seat $seat): Seat
    {
        $seat->setPlayer($player);
        $seat->setStatus(SeatStatus::WAITING);
        $player->setStatus(PlayerStatus::SEATED);
        return $seat;
    }
    public function reserveSeat(Player $player, Seat $seat): Seat
    {
        $seat->setPlayer($player);
        $seat->setStatus(SeatStatus::RESERVED);
        $player->setStatus(PlayerStatus::SEAT_RESERVED);
        return $seat;
    }
    public function new_hand(): void
    {
        $this->hand_count++;
        $hand_count_display = number_format($this->hand_count, 0, '.', ',');
        echo ("=============================================================\n");
        $this->chat("Starting hand #$hand_count_display of " . $this->config["limit"]->display() . " " . $this->config['GameType']->display() . " [$" . $this->config['smallBlind'] . "/$" . $this->config['bigBlind'] . "]");
        $this->config['status'] = TableStatus::STARTING;
        $players_ready = $this->resetSeats();
        if ($players_ready < 2) {
            $this->chat("Not enough players to start a new hand.");
            die();
        }
        $this->muck = [];
        $this->communityCards = [];
        $this->pots = [];
        $this->pots[0] = new Pot(0, false);
        $this->bet = $this->config["bigBlind"];
        $this->advanceButton();
        $this->deck = new Deck();
        $this->action_position = $this->postBlinds();
        $this->deck->shuffle();
        $this->deck->cut();
        $this->dealHoleCards();
        $this->config['status'] = TableStatus::PREFLOP;
        $this->bettingRound();
        if ($this->config['status'] == TableStatus::HAND_OVER) return;
        $this->config['status'] = TableStatus::FLOP;
        $this->deck->dealCard($this->muck);
        $this->deck->dealCard($this->communityCards);
        $this->deck->dealCard($this->communityCards);
        $this->deck->dealCard($this->communityCards);
        echo ("========================================\n");
        $this->chat("Flop:\t[" . implode("] [", $this->communityCards) . "]");
        $this->bettingRound();
        if ($this->config['status'] == TableStatus::HAND_OVER) return;
        $this->config['status'] = TableStatus::TURN;
        $this->deck->dealCard($this->muck);
        $this->deck->dealCard($this->communityCards);
        echo ("========================================\n");
        $this->chat("Turn:\t[" . implode("] [", $this->communityCards) . "]");
        $this->bettingRound();
        if ($this->config['status'] == TableStatus::HAND_OVER) return;
        $this->config['status'] = TableStatus::RIVER;
        $this->deck->dealCard($this->muck);
        $this->deck->dealCard($this->communityCards);
        echo ("========================================\n");
        $this->chat("River:\t[" . implode("] [", $this->communityCards) . "]");
        $this->action_position = $this->button_position;
        $this->bettingRound();
        if ($this->config['status'] == TableStatus::HAND_OVER) return;
        $this->config['status'] = TableStatus::SHOWDOWN;
        $this->showdown();
    }
    private function showdown(): void
    {
        foreach ($this->pots as $key => $pot) {
            if ($key == 0) $pot_display = "the Main Pot";
            else $pot_display = "Side Pot $key";
            $hands = [];
            foreach ($pot->eligible as $seat_num => $seat) {
                $hands[$seat_num] = $seat->cards;
            }
            $winning_seats = $this->HandEvaluator->get_winner_indexes($hands, $this->communityCards);
            $results = $pot->payout($winning_seats, $pot_display);
            foreach ($results as $result) $this->chat($result);
        }
    }
    private function bettingRound(): void
    {
        $this->action_position = $this->button_position;
        $this->pots[0]->good = false;
        while (!$this->potsGood()) {
            $action_order = $this->getActionOrder();
            foreach ($action_order as $seat_number) {
                $seat = $this->seats[$seat_number];
                $seat->prompt($this);
            }
            $this->pots[0]->good = true;
        }
    }
    private function potsGood(): bool
    {
        foreach ($this->pots as $pot) {
            if (!$pot->good) return false;
        }
        return true;
    }
    private function getActionOrder(): array
    {
        $action_order = [];
        $seat_number = $this->action_position;
        while (true) {
            $seat_number++;
            if ($seat_number >= count($this->seats)) $seat_number = 0;
            $seat = $this->seats[$seat_number];
            if (in_array($seat->getStatus(), [SeatStatus::PLAYING, SeatStatus::POSTED])) $action_order[] = $seat_number;
            if ($seat_number == $this->action_position) break;
        }
        return $action_order;
    }
    private function dealHoleCards(): void
    {
        $deal_order = $this->getDealOrder();
        for ($i = 0; $i < $this->config["GameType"]->num_hole_cards(); $i++) {
            foreach ($deal_order as $seat_number) {
                $this->deck->dealCard($this->seats[$seat_number]->cards);
            }
        }
    }
    private function getDealOrder(): array
    {
        $deal_order = [];
        $seat_number = $this->button_position;
        while (true) {
            $seat_number++;
            if ($seat_number >= count($this->seats)) $seat_number = 0;
            $seat = $this->seats[$seat_number];
            if (in_array($seat->getStatus(), [SeatStatus::PLAYING, SeatStatus::POSTED])) $deal_order[] = $seat_number;
            if ($seat_number == $this->button_position) break;
        }
        return $deal_order;
    }
    private function postBlinds(): int
    {
        return $this->postBigBlind($this->postSmallBlind());
    }
    private function postSmallBlind(): int
    {
        $small_blind_amount = $this->config['smallBlind'];
        $small_blind_seat_number = $this->getNextActiveSeat($this->button_position);
        $small_blind_seat = $this->seats[$small_blind_seat_number];
        while ($small_blind_seat->getStack()->getAmount() < $small_blind_amount) {
            $small_blind_seat->setStatus(SeatStatus::SITOUT);
            $small_blind_seat_number = $this->getNextActiveSeat($this->button_position);
            $small_blind_seat = $this->seats[$small_blind_seat_number];
        }
        $this->pots[0]->contribute($small_blind_amount, $small_blind_seat);
        $small_blind_seat->setStatus(SeatStatus::POSTED);
        $small_blind_seat->bet = $small_blind_amount;
        $this->chat($small_blind_seat->getPlayer()->getName() . " posts the small blind of $" . $small_blind_amount);
        return $small_blind_seat_number;
    }
    private function postBigBlind($small_blind_seat_number): int
    {
        $big_blind_amount = $this->config['bigBlind'];
        $big_blind_seat_number = $this->getNextActiveSeat($small_blind_seat_number);
        $big_blind_seat = $this->seats[$big_blind_seat_number];
        while ($big_blind_seat->getStack()->getAmount() < $big_blind_amount) {
            $big_blind_seat->setStatus(SeatStatus::SITOUT);
            $big_blind_seat_number = $this->getNextActiveSeat($this->button_position + 2);
            $big_blind_seat = $this->seats[$big_blind_seat_number];
        }
        $this->pots[0]->contribute($big_blind_amount, $big_blind_seat);
        $big_blind_seat->setStatus(SeatStatus::POSTED);
        $big_blind_seat->bet = $big_blind_amount;
        $this->chat($big_blind_seat->getPlayer()->getName() . " posts the big blind of $" . $big_blind_amount);
        return $big_blind_seat_number;
    }
    private function advanceButton(): void
    {
                $this->button_position = $this->getNextActiveSeat($this->button_position);
        $this->chat("The button is at seat " . $this->button_position . ". ({$this->seats[$this->button_position]->getPlayer()->getName()})");
    }
    private function getNextActiveSeat($seat): int
    {
        $seat++;
        if ($seat >= count($this->seats)) $seat = 0;
        if (!in_array($this->seats[$seat]->getStatus(), [SeatStatus::PLAYING, SeatStatus::POSTED])) $seat = $this->getNextActiveSeat($seat);
        return $seat;
    }
    public function resetSeats(): int
    {
        $players_ready = 0;
        echo ("Seat\tBankroll\tChips In Play  \tPlayer Name\n");
        foreach ($this->seats as $seat_number => $seat) {
            $seat->clearCards();
            switch ($seat->getStatus()) {
                case SeatStatus::WAITING:
                case SeatStatus::POSTED:
                case SeatStatus::FOLDED:
                case SeatStatus::PLAYING:
                    if ($seat->getStack()->getAmount() < $this->config['bigBlind']) $seat->setStatus(SeatStatus::SITOUT);
                    else {
                        $seat->setStatus(SeatStatus::PLAYING);
                        $seat->topUp($this->config['maxBuyIn']);
                        $this->chat("$seat_number\t{$seat->getPlayer()->getBankRoll()}\t{$seat->getStack()}\t{$seat->getPlayer()->getName()}");
                        $players_ready++;
                    }
                    break;
                case SeatStatus::TIMEOUT:
                    $seat->setStatus(SeatStatus::SITOUT);
                    break;
                default:
                    break;
            }
        }
        return $players_ready;
    }
    public function chat($message)
    {
        $this->chat_history[] = $message;
        echo ($message . "\n");
    }
}

$build_info = json_decode(file_get_contents('build_info.json'), true);
echo ("poker (cli) v" . $build_info["number"] . " (built: " . $build_info["date"] . ")\n");
$casino = new Casino("My Casino");
$table = $casino->addTable(new Table([
    "id" => 1,
    "name" => "My Table",
    "seats" => 2,
]));
$player1 = $casino->addPlayer(new Player("Russell", PlayerType::HUMAN));
$casino->buyChips($player1, 10000);
$table->seatPlayer($player1, $table->seats[0])->buyChips(1000);
$player2 = $casino->addPlayer(new Player("Lily", PlayerType::BOT));
$casino->buyChips($player2, 10000);
$table->seatPlayer($player2, $table->seats[1])->buyChips(1000);
for ($i = 0; $i < 1; $i++) {
    $table->new_hand();
}
